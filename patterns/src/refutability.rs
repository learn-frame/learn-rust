//! 在一些地方, 模式必须是 irrefutable(不可反驳) 的, 意味着他们必须匹配所提供的任何值.
//! 在另一些情况, 他们则可以是 refutable(可反驳) 的
//!
//! 能匹配任何传递的可能值的模式被称为是不可反驳的.
//! 一个例子就是 let x = 5; 语句中的 x, 因为 x 可以匹配任何值所以不可能会失败
//!
//! 对某些可能的值进行匹配会失败的模式被称为是可反驳的.
//! 一个这样的例子便是 if let Some(x) = a_value 表达式中的 Some(x); 如果变量 a_value 中的值是 None 而不是 Some, 那么 Some(x) 模式不能匹配
//!
//! 函数参数, let 语句和 for 循环只能接受不可反驳的模式, 因为通过不匹配的值程序无法进行有意义的工作
//!
//! if let 和 while let 表达式被限制为只能接受可反驳的模式, 因为根据定义他们意在处理可能的失败: 条件表达式的功能就是根据成功或失败执行不同的操作

pub fn entry() {
    // let 后面应该跟一个不可反驳的模式
    // let Some(x) = 1;

    // 可以改成 if let 的模式
    if let Some(x) = Option::Some(1) {
        println!("{}", x);
    }

    // if let 后面应该可反驳模式
    // if let x = 5 {
    //     println!("{}", x);
    // };
}
