// Rust æ˜¯é™æ€ç±»å‹(statically typed)è¯­è¨€, ä¹Ÿå°±æ˜¯è¯´åœ¨ç¼–è¯‘æ—¶å°±å¿…é¡»çŸ¥é“æ‰€æœ‰å˜é‡çš„ç±»å‹
// use std::num::Wrapping;

use std::{
    f32::{INFINITY, NEG_INFINITY},
    i32::{MAX, MIN},
    ops::{Bound::*, RangeBounds},
};

fn main() {
    // å½“å¤šç§ç±»å‹å‡æœ‰å¯èƒ½æ—¶, å¿…é¡»å¢åŠ ç±»å‹æ³¨è§£
    // å¿…é¡»æ˜¾å¼æŒ‡å®šå˜é‡çš„æ•°æ®ç±»å‹
    let number_from_string: u32 = "42".parse().expect("å¿…é¡»æ˜¯ä¸ªæ•°å­—å­—ç¬¦ä¸²å•Šå–‚");
    println!("{}", number_from_string);

    // æ ‡é‡ç±»å‹
    // Rust æœ‰å››ç§åŸºæœ¬çš„æ ‡é‡ç±»å‹: æ•´å‹, æµ®ç‚¹å‹, å¸ƒå°”ç±»å‹å’Œå­—ç¬¦ç±»å‹(characters)

    // æ•´å‹
    // Length	 Signed	                                    Unsigned                                å¤‡æ³¨
    //
    // 8-bit	 i8(-2^â· - 2^â·â»Â¹)	                        u8(0 - 2^â¸â»Â¹)                           å ç”¨ 1 ä¸ªå­—èŠ‚, u8 ç±»å‹é€šå¸¸åœ¨ Rust ä¸­è¡¨ç¤ºå­—èŠ‚åºåˆ—, åœ¨æ–‡ä»¶ I/O æˆ–ç½‘ç»œ I/O ä¸­è¯»å–æ•°æ®æµæ—¶éœ€è¦ä½¿ç”¨ u8.
    // 16-bit	 i16(-2^Â¹âµ - 2^Â¹âµâ»Â¹)	  	                u16(0 - 2^Â¹â¶â»Â¹)                         å ç”¨ 2 ä¸ªå­—èŠ‚
    // 32-bit	 i32(-2^Â³Â¹ - 2^Â³Â¹â»Â¹)	  	                u32(0 - 2^Â³Â²â»Â¹)                         å ç”¨ 4 ä¸ªå­—èŠ‚
    // 64-bit	 i64(-2^â¶Â³ - 2^â¶Â³â»Â¹)	  	                u64(0 - 2^â¶â´â»Â¹)                         å ç”¨ 8 ä¸ªå­—èŠ‚
    // 128-bit	 i128(-2^Â¹Â²â· - 2^Â¹Â²â·â»Â¹)	  	                u128(0 - 2^Â¹Â²â¸â»Â¹)                       å ç”¨ 16 ä¸ªå­—èŠ‚
    // arch	     isize(-2^Â³Â¹ - 2^Â³Â¹â»Â¹ æˆ– -2^â¶Â³ - 2^â¶Â³â»Â¹)  	usize(0 - 2^Â³Â²â»Â¹ æˆ– 0 - 2^â¶â´â»Â¹)         å ç”¨ 4 æˆ– 8 ä¸ªå­—èŠ‚, å…·ä½“å–å†³äºæœºå™¨çš„å­—é•¿, å­—é•¿å¯ä»¥ç†è§£ä¸º 32ä½ç³»ç»Ÿ / 64 ä½ç³»ç»Ÿ

    // æœ‰ç¬¦å·æ•°: å¯ä»¥ä¸ºæ­£æ•°, ä¹Ÿå¯ä»¥ä¸ºè´Ÿæ•°, å’Œ 0; æœ‰ç¬¦å·æ•°ä»¥è¡¥ç å½¢å¼(two's complement representation) å­˜å‚¨; æ¯ä¸€ä¸ªæœ‰ç¬¦å·çš„å˜ä½“å¯ä»¥å‚¨å­˜åŒ…å«ä» -(2^n - 1) åˆ° 2^(n-1) - 1 åœ¨å†…çš„æ•°å­—
    // æ— ç¬¦å·æ•°: åªèƒ½ä¸ºæ­£æ•´æ•°å’Œ 0; æ— ç¬¦å·çš„å˜ä½“å¯ä»¥å‚¨å­˜ä» 0 åˆ° 2^(n-1) çš„æ•°å­—
    // isize å’Œ usize ç±»å‹ä¾èµ–è¿è¡Œç¨‹åºçš„è®¡ç®—æœºæ¶æ„:64 ä½æ¶æ„ä¸Šå®ƒä»¬æ˜¯ 64 ä½çš„, 32 ä½æ¶æ„ä¸Šå®ƒä»¬æ˜¯ 32 ä½çš„

    // æ•°å­—å­—é¢å€¼	                 ä¾‹å­
    // Decimal (åè¿›åˆ¶)	             98_222
    // Hex (åå…­è¿›åˆ¶)	             0xff
    // Octal (å…«è¿›åˆ¶)	             0o77
    // Binary (äºŒè¿›åˆ¶)	             0b1111_0000
    // Byte (å•å­—èŠ‚å­—ç¬¦)(ä»…é™äºu8)	  b'A'

    // æ•´å‹æ”¯æŒäºŒ, å…«, å, åå…­è¿›åˆ¶å’Œå•å­—èŠ‚å­—ç¬¦
    // rust å…è®¸ä½¿ç”¨ _ åšä¸ºåˆ†éš”ç¬¦ä»¥æ–¹ä¾¿è¯»æ•°, å¦‚ 1_000_000 ç­‰ä»·äº 1000000

    // æ•´å‹æº¢å‡º, å› ä¸º i8 æœ€å¤§åˆ° 255
    // è¿™å¥è¯ä¼šåœ¨ç¼–è¯‘é˜¶æ®µæŠ¥é”™, ä½†åœ¨ release é˜¶æ®µ, ä¼šå°† 256 å˜æˆ 0, 257 å˜æˆ 1, ä¾æ­¤ç±»æ¨. è¿™å«åšäºŒè¿›åˆ¶è¡¥ç åŒ…è£…(two's complement wrapping).
    // æ ‡å‡†åº“ä¸­æœ‰ä¸€ä¸ª Wrapping æ¥æ˜¾å¼å¤„ç†æº¢å‡º: https://doc.rust-lang.org/std/num/struct.Wrapping.html
    // ä¸è¿‡ Wrapping å¤§å¤šéƒ½å±äºå®éªŒä¸­çš„
    // let num: i8 = 256;

    // æµ®ç‚¹å‹
    // æœ‰ f32 å’Œ f64 ä¸¤ç§, åˆ†åˆ«å  32 ä½å’Œ 64 ä½, é»˜è®¤æ˜¯ f64
    // æµ®ç‚¹æ•°é‡‡ç”¨ IEEE-754 æ ‡å‡†è¡¨ç¤º. f32 æ˜¯å•ç²¾åº¦æµ®ç‚¹æ•°, f64 æ˜¯åŒç²¾åº¦æµ®ç‚¹æ•°
    println!("{}", 0.1 + 0.2); // 0.30000000000000004 å“ˆå“ˆå“ˆæˆ‘å°±çŸ¥é“

    // æ•°å€¼è¿ç®—
    // æ‰€æœ‰è¿ç®—ç¬¦åˆ—è¡¨: https://doc.rust-lang.org/book/appendix-02-operators.html
    println!("{}", 4.0 / 3.0); // 1.3333333333333333, å¦‚æœæ˜¯ float è¿ç®—äº§ç”Ÿå°æ•°, ä¼šå¸¦å°æ•°
    println!("{}", 4 / 3); // 1, å¦‚æœä¸¤ä¸ªæ•´å‹äº§ç”Ÿå°æ•°, ä¼šæŠŠå°æ•°æŠ¹æ‰, è¿™åœ¨ç®—æ³•é¢˜å¤§æ•°åŠ æ³•ç›¸å…³é¢˜ç›®ä¸­æ±‚å•†å¾ˆæœ‰ç”¨.

    let a: i8 = 4;
    let b: i8 = 0b1111;
    let c: f32 = 1.0;
    let d: i32 = 4;
    let e: f64 = 2.0;
    let f = 4u32; // å¯ä»¥é€šè¿‡ç›´æ¥ä½¿ç”¨ç±»å‹åç¼€æ¥å‘ŠçŸ¥ç¼–è¯‘å™¨è¿™ä¸ªæ•´å‹æ•°å­—æ˜¯ä¸ª u32 çš„, å¦åˆ™é»˜è®¤è¢«æ¨ç®—æˆ i32
    let g = MAX;
    let i = MIN;
    let j = INFINITY;
    let k = NEG_INFINITY;
    assert_eq!(b'A', 65u8); // äºŒè¿›åˆ¶å¯ä»¥ç”¨ b å‰ç¼€

    // ğŸ‘¿ å¿…é¡»æ˜¯ç›¸åŒç±»å‹æ‰èƒ½åšåŠ å‡ä¹˜é™¤å–ä½™
    println!("{}", a + b);
    println!("{} {} {} {}", c, d, e, f);
    println!("{} {} {} {}", g, i, j, k);

    // ğŸ‘¿ i8 å’Œ i32 æ— æ³•è¿›è¡Œè¿ç®—
    // println!("{}", a + d);

    // ğŸ‘¿ int ç±»å‹å’Œ float ç±»å‹ä¸èƒ½è¿›è¡Œè¿ç®—, è¯¸å¦‚æ­¤ç±», äº‘äº‘.
    // println!("{}", c * a);

    // å¸ƒå°”å‹
    let t = true;
    let f: bool = false; // æ˜¾å¼æŒ‡å®šç±»å‹æ³¨è§£
    let truely = t as i32; // å¯ä»¥é€šè¿‡ as å°† bool -> i32, u32, i8, usize... ä½†ä¸å¯ä»¥è½¬æˆå…¶ä»–ç±»å‹, æ¯”å¦‚ float, str; æ­¤å¤–åªèƒ½ bool -> int, åè¿‡æ¥ä¸è¡Œ
    let falsy = f as i32;
    println!("{} {} {} {}", t, f, truely, falsy);

    // å­—ç¬¦ç±»å‹
    // å­—ç¬¦ç±»å‹ä»£è¡¨çš„æ˜¯ä¸€ä¸ª Unicode æ ‡é‡å€¼.
    // å­—ç¬¦ç±»å‹æ˜¯è¯­è¨€ä¸­æœ€åŸç”Ÿçš„å­—æ¯ç±»å‹, å®ƒå¿…é¡»æ˜¯å•ä¸ªå­—ç¬¦, æ¯”å¦‚ 'a', 'b', ä½†å¯ä»¥æ˜¯ 'ğŒ†' 'ğŸ˜»' ç­‰å››å­—ç¬¦.
    // æ³¨æ„è¦è·Ÿå­—ç¬¦ä¸²åŒºåˆ†, å­—ç¬¦ç±»å‹ç”¨çš„æ˜¯å•å¼•å·, å­—ç¬¦ä¸²æ˜¯åŒå¼•å·
    // å…·ä½“åŒºåˆ†: https://doc.rust-lang.org/book/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
    // Rust çš„ char ç±»å‹çš„å¤§å°ä¸ºå››ä¸ªå­—èŠ‚, å¹¶ä»£è¡¨äº†ä¸€ä¸ª Unicode æ ‡é‡å€¼(Unicode Scalar Value)
    let f = 'z';
    let g = 'â„¤';
    let h = 'ğŸ˜»';
    let i = '\x2A';
    let j = '\u{CA0}';

    // ä½¿ç”¨ as æ“ä½œç¬¦å°†å­—ç¬¦è½¬ä¸ºæ•°å­—ç±»å‹, æ¯”å¦‚ % çš„åè¿›åˆ¶ ASCII æ˜¯ 37, é‚£ç»“æœå°±æ˜¯ 37
    // à²  æ˜¯ 3232, å¦‚æœå¼ºåˆ¶è½¬ i8 çš„è¯, é«˜ä½ä¼šè¢«æˆªå–, å˜æˆ -96
    let k = '%' as i8; // 37
    let l = 'à² ' as i8; // 96
    println!("{} {} {} {} {} {} {}", f, g, h, i, j, k, l);

    //: å¤åˆç±»å‹
    //: Rust æœ‰ä¸¤ç§åŸºæœ¬çš„å¤åˆç±»å‹: å…ƒç»„, æ•°ç»„

    /* å…ƒç»„ */
    // let a = [3; 5];
    let tup = (500, 6.4, "str");
    // æ ¹æ®ä¸‹æ ‡è·å–å…ƒç»„å…ƒç´ 
    println!("{}, {}", tup.0, tup.1);
    // è§£æ„å…ƒç»„, å› ä¸º let æ”¯æŒæ¨¡å¼åŒ¹é…, æ‰€ä»¥å¯ä»¥ç”¨æ¥è§£æ„å…ƒç»„.
    // å¦‚æœä½¿ç”¨å…ƒç»„è§£æ„, ä½ å¿…é¡»æŠŠæ‰€æœ‰å…ƒç´ éƒ½è§£æ„å‡ºæ¥, å¦åˆ™æŠ¥é”™...
    let (i, j, k) = tup;
    println!("The value of i is: {}", i);
    println!("{} {}", j, k);
    // æšä¸¾å…ƒç»„ä¸­çš„æ‰€æœ‰å€¼
    println!("{:?}", tup);
    // å¾ˆé•¿çš„å…ƒç»„æ— æ³•æ‰“å°, è¿™ä¹ˆæ“è›‹çš„å—...
    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    // println!("too long tuple: {:?}", too_long_tuple);
    // æ²¡æœ‰ä»»ä½•å€¼çš„å…ƒç»„ () æ˜¯ä¸€ç§ç‰¹æ®Šçš„ç±»å‹, åªæœ‰ä¸€ä¸ªå€¼, ä¹Ÿå†™æˆ (). è¯¥ç±»å‹è¢«ç§°ä¸º å•å…ƒç±»å‹(unit type),
    // è€Œè¯¥å€¼è¢«ç§°ä¸º å•å…ƒå€¼(unit value). å¦‚æœè¡¨è¾¾å¼ä¸è¿”å›ä»»ä½•å…¶ä»–å€¼, åˆ™ä¼šéšå¼è¿”å›å•å…ƒå€¼
    let l = ();
    println!("{:?}", l);
    let tup = (0,); // å¦‚æœå…ƒç»„åªæœ‰ä¸€ä¸ªå…ƒç´ , å¿…é¡»åŠ ä¸€ä¸ªé€—å·
    println!("{:?}", tup);

    /* æ•°ç»„ [T; N], å¿…é¡»æ˜¯ä¸€è‡´çš„ç±»å‹, ä¸”é•¿åº¦å¿…é¡»ä¸ºç¼–è¯‘æ—¶å¸¸é‡, é»˜è®¤ä¸å¯å˜ */
    // å¯¹äºåŸå§‹å›ºå®šé•¿åº¦æ•°ç»„, åªæœ‰å®ç° Copy trait çš„ç±»å‹æ‰èƒ½ä½œä¸ºå…¶å…ƒç´ , ä¹Ÿå°±æ˜¯è¯´, åªæœ‰å¯ä»¥åœ¨æä¸Šå­˜æ”¾çš„å…ƒç´ æ‰å¯ä»¥å­˜æ”¾åœ¨è¯¥ç±»å‹çš„æ•°ç»„ä¸­

    // let m = [1, 2, 3, 4, 5, ""]; // ğŸ‘¿ æŠ¥é”™, å¿…é¡»æ˜¯ä¸€è‡´çš„ç±»å‹
    let mut n = ["Yancey", "Sayaka"];

    // æ•°ç»„ä¸€æ—¦åˆ›å»ºå°±ä¸å¯ä¿®æ”¹é•¿åº¦äº†, å®ƒæ²¡æœ‰ push pop ç­‰æ–¹æ³•
    // æ­¤å¤–å’Œå…¶ä»–æ•°æ®ç±»å‹ä¸€æ ·é»˜è®¤æ˜¯ä¸å¯å˜çš„, é™¤éä½ åŠ ä¸Š mut, ä½†å³ä¾¿åŠ ä¸Šäº† mut, ä¹Ÿåªèƒ½ä¿®æ”¹å·±å­˜åœ¨äºç´¢å·ä½ä¸Šçš„å…ƒç´ 
    n[1] = "Yancey"; // å¯ä»¥
                     // n[5] = "hello"; // ğŸ‘¿ è¿è¡Œæ—¶å‡ºé”™, ç¼–è¯‘æ—¶æ˜¯æ— æ³•æ£€æµ‹æ•°ç»„è®¿é—®å…ƒç´ æº¢å‡ºçš„

    // for...in
    for val in n.iter() {
        println!("val is :{}", val);
    }

    // å¯¹äºé•¿åº¦å›ºå®šçš„, ç”¨æ•°ç»„æ¯”è¾ƒå¥½, å¯å˜çš„å»ºè®®ç”¨ vector
    let o = vec![1, 2, 3];
    println!("{:?}", o);
    // println!("{:?}", o[4]);  // ğŸ‘¿ ä¹Ÿè¿è¡Œæ—¶å‡ºé”™, ç¼–è¯‘æ—¶æ˜¯æ— æ³•æ£€æµ‹æ•°ç»„è®¿é—®å…ƒç´ æº¢å‡ºçš„

    // è¿™ä¸ªå°±æ¯”è¾ƒéªš, ç­‰ä»·äº [3, 3, 3, 3, 3]
    let p = [3; 5];
    println!("{:?}", p);

    // æˆ‘çˆ†å“­ qwq, ç”¨ js åˆ·åŠ¨æ€è§„åˆ’çš„ leetcode é¢˜, åˆå§‹åŒ–äºŒç»´æ•°ç»„è´¼éº»çƒ¦.
    let q = [[""; 5]; 5];

    // å¯¹äºæ•°ç»„çš„æ‰“å°, å’Œå…ƒç»„ç±»ä¼¼, éƒ½å¾—ç”¨ {:?}
    println!("{:?}", q);
    let u = n[0];
    println!("{:?}", u);

    /* èŒƒå›´ç±»å‹ */
    assert_eq!(std::ops::Range { start: 1, end: 5 }, (1..5)); // å‰é—­åå¼€
    assert_eq!(std::ops::RangeInclusive::new(1, 5), (1..=5)); // å‰é—­åé—­
    assert_eq!(1 + 2 + 3, (1..=3).sum()); // èŒƒå›´ç±»å‹è‡ªå¸¦ä¸€äº›æ–¹æ³•, æ¯”å¦‚ sum
    assert!((1..=3).contains(&2)); // èŒƒå›´ç±»å‹è‡ªå¸¦ä¸€äº›æ–¹æ³•, æ¯”å¦‚ contains
    assert_eq!((1..).end_bound(), Unbounded); // èŒƒå›´ç±»å‹è‡ªå¸¦ä¸€äº›æ–¹æ³•, æ¯”å¦‚ end_bound
    assert_eq!((..1).start_bound(), Unbounded); // èŒƒå›´ç±»å‹è‡ªå¸¦ä¸€äº›æ–¹æ³•, æ¯”å¦‚ start_bound
    assert_eq!((1..3).end_bound(), Excluded(&3)); // èŒƒå›´ç±»å‹è‡ªå¸¦ä¸€äº›æ–¹æ³•, æ¯”å¦‚ end_bound
    assert_eq!((1..=3).end_bound(), Included(&3)); // èŒƒå›´ç±»å‹è‡ªå¸¦ä¸€äº›æ–¹æ³•, æ¯”å¦‚ end_bound
    for _ in 1..=3 {} // èŒƒå›´ç±»å‹è‡ªå¸¦è¿­ä»£å™¨, å¯ä»¥ç›´æ¥ä½¿ç”¨ for...in

    /* åˆ‡ç‰‡ç±»å‹ */
    // åˆ‡ç‰‡(Slice)ç±»å‹æ˜¯å¯¹ä¸€ä¸ªæ•°ç»„(åŒ…æ‹¬å›ºå®šå¤§å°æ•°ç»„å’ŒåŠ¨æ€æ•°ç»„)çš„å¼•ç”¨ç‰‡æ®µ, ç­¾åä¸º &[T] å’Œ &mut [T].
    let arr = [1, 2, 3, 4];
    let vec = vec![1, 2, 3, 4];
    // let arr_2 = arr[1..]; ğŸ‘¿ ä¸èƒ½å¯¹æ•°ç»„/å¯å˜æ•°ç»„è¿™æ ·åˆ‡
    assert_eq!(&arr[1..], [2, 3, 4]); // åªèƒ½ä½¿ç”¨åˆ‡ç‰‡
    assert_eq!(&vec[1..], [2, 3, 4]); // åªèƒ½ä½¿ç”¨åˆ‡ç‰‡
    assert_eq!(&vec[1..].len(), &3); // len æ–¹æ³•, æ˜¯ const fn æ–¹æ³•
    assert!(&vec[4..].is_empty()); // is_empty æ–¹æ³•, æ˜¯ const fn æ–¹æ³•

    /* str å­—ç¬¦ä¸²ç±»å‹ */
    let str: &'static str = "Hello, world"; // 'static çš„ç”Ÿå‘½å‘¨æœŸèƒ½å¤Ÿå­˜æ´»äºæ•´ä¸ªç¨‹åºæœŸé—´. æ‰€æœ‰çš„å­—ç¬¦ä¸²å­—é¢å€¼éƒ½æ‹¥æœ‰ 'static ç”Ÿå‘½å‘¨æœŸ
    let ptr = str.as_ptr();
    let len = str.len();
    let str_1 = unsafe {
        let slice = std::slice::from_raw_parts(ptr, len);
        std::str::from_utf8(slice)
    };
    assert_eq!(str_1, Ok(str));

    /* åŸç”ŸæŒ‡é’ˆ */
    // è¡¨ç¤ºå†…å­˜åœ°å€çš„ç±»å‹ç§°ä¸ºæŒ‡é’ˆ, Rust æä¾›äº†å¤šç§æŒ‡é’ˆç±»å‹:
    // å¼•ç”¨(Reference)
    // åŸç”ŸæŒ‡é’ˆ(Raw Pointer)
    // å‡½æ•°æŒ‡é’ˆ(fn Pointer)
    // æ™ºèƒ½æŒ‡é’ˆ(Smart Pointer)

    // Rust åˆ†ä¸º Safe Rust å’Œ Unsafe Rust
    // å¼•ç”¨æ˜¯ä¸€ç§éç©ºæŒ‡é’ˆ, åœ¨ Safe Rust ä¸­, ç¼–è¯‘å™¨ä¼šå¯¹å¼•ç”¨è¿›è¡Œå€Ÿç”¨æ£€æŸ¥, ä»¥ä¿è¯å†…å­˜å®‰å…¨å’Œç±»å‹å®‰å…¨
    // è€ŒåŸç”ŸæŒ‡é’ˆæ˜¯ä¸å®‰å…¨çš„, æ¯”å¦‚åŸç”ŸæŒ‡é’ˆå¯èƒ½æŒ‡å‘ Null, æˆ–è€…ä¸€ä¸ªå·²ç»è¢«é‡Šæ”¾çš„å†…å­˜åŒºåŸŸ(æ‚¬å‚å¼•ç”¨)
    // å› ä¸ºä½¿ç”¨åŸç”ŸæŒ‡é’ˆçš„åœ°æ–¹ä¸åœ¨ Safe Rust çš„å¯æ§èŒƒå›´å†…ï¼Œæ‰€ä»¥éœ€è¦ç¨‹åºå‘˜è‡ªå·±ä¿è¯å®‰å…¨.
    // Rust æ”¯æŒä¸¤ç§åŸç”ŸæŒ‡é’ˆ:
    // ä¸å¯å˜åŸç”ŸæŒ‡é’ˆ *const T
    // å¯å˜åŸç”ŸæŒ‡é’ˆ *mut T

    {
        let mut x = 10;
        let ptr_x = &mut x as *mut i32; // é€šè¿‡ as å°† &mut x å¯å˜å¼•ç”¨è½¬æ¢ä¸º *mut i32 å¯å˜åŸç”ŸæŒ‡é’ˆ ptr_x
        let y = Box::new(20); // é€šè¿‡ Box å°†æ•°å­— 20 å­˜åˆ°å †å†…å­˜ä¸Š
        let ptr_y = &*y as *const i32; // å°† y è½¬æ¢æˆåŸç”ŸæŒ‡é’ˆ ptr_y

        unsafe {
            *ptr_x += *ptr_y; // ä¸¤ä¸ªåŸç”ŸæŒ‡é’ˆç›¸åŠ 
        }
        assert_eq!(x, 30);
    }

    /* never ç±»å‹ */
    // nerver ç±»å‹(!)æ˜¯ä¸€ä¸ªæ²¡æœ‰å€¼çš„ç±»å‹, è¡¨ç¤ºæ°¸è¿œä¸ä¼šå®Œæˆè®¡ç®—çš„ç»“æœ.
    // ! çš„ç±»å‹è¡¨è¾¾å¼å¯ä»¥å¼ºè½¬ä¸ºä»»ä½•å…¶ä»–ç±»å‹. ç›®å‰ ! åªåœ¨ nightly ç‰ˆæœ¬, è¿˜ä¸ç¨³å®š.
    // let x: ! = panic!();
    // let y: u32 = x;
}

// ç±»å‹ç³»ç»Ÿä¸å¤šæ€æ€§
// å¦‚æœä¸€ä¸ªç±»å‹ç³»ç»Ÿå…è®¸ä¸€æ®µä»£ç åœ¨ä¸åŒçš„ä¸Šä¸‹æ–‡ä¸­å…·æœ‰ä¸åŒçš„ç±»å‹, è¿™æ ·çš„ç±»å‹ç³»ç»Ÿå°±å«ä½œå¤šæ€ç±»å‹ç³»ç»Ÿ. å¯¹äºé™æ€ç±»å‹çš„è¯­è¨€æ¥è¯´, å¤šæ€æ€§çš„å¥½å¤„æ˜¯å¯ä»¥åœ¨ä¸å½±å“ç±»å‹ä¸°å¯Œçš„å‰æä¸‹, ä¸ºä¸åŒçš„ç±»å‹ç¼–å†™é€šç”¨çš„ä»£ç .
// ç°ä»£ç¼–ç¨‹è¯­è¨€åŒ…å«äº†ä¸‰ç§å¤šæ€å½¢å¼: å‚æ•°åŒ–å¤šæ€(Parametric polymorphism), Ad-hoc å¤šæ€(Ad-hoc polymorphism)å’Œå­ç±»å‹å¤šæ€(Subtype polymorphism).
// å¦‚æœæŒ‰ç…§å¤šæ€å‘ç”Ÿæ—¶é—´æ¥åˆ’åˆ†, åˆå¯åˆ†ä¸ºé™å¤šæ€(Static polymorphism)å’ŒåŠ¨å¤šæ€(Dynamic polymorphism)