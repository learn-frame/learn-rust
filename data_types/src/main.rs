// Rust æ˜¯é™æ€ç±»å‹(statically typed)è¯­è¨€, ä¹Ÿå°±æ˜¯è¯´åœ¨ç¼–è¯‘æ—¶å°±å¿…é¡»çŸ¥é“æ‰€æœ‰å˜é‡çš„ç±»å‹
// use std::num::Wrapping;

use std::{
    borrow::Borrow,
    f32::{INFINITY, NEG_INFINITY},
    i32::{MAX, MIN},
    ops::{Bound::*, Deref, RangeBounds},
    rc::Rc,
};

fn main() {
    // å½“å¤šç§ç±»å‹å‡æœ‰å¯èƒ½æ—¶, å¿…é¡»å¢åŠ ç±»å‹æ³¨è§£
    // å¿…é¡»æ˜¾å¼æŒ‡å®šå˜é‡çš„æ•°æ®ç±»å‹
    let number_from_string: u32 = "42".parse().expect("å¿…é¡»æ˜¯ä¸ªæ•°å­—å­—ç¬¦ä¸²å•Šå–‚");
    println!("{}", number_from_string);

    // æ ‡é‡ç±»å‹
    // Rust æœ‰å››ç§åŸºæœ¬çš„æ ‡é‡ç±»å‹: æ•´å‹, æµ®ç‚¹å‹, å¸ƒå°”ç±»å‹å’Œå­—ç¬¦ç±»å‹(characters)

    // æ•´å‹
    // Length	 Signed	                                    Unsigned                                å¤‡æ³¨
    //
    // 8-bit	 i8(-2^â· - 2^â·-1)	                        u8(0 - 2^â¸-1)                           å ç”¨ 1 ä¸ªå­—èŠ‚, u8 ç±»å‹é€šå¸¸åœ¨ Rust ä¸­è¡¨ç¤ºå­—èŠ‚åºåˆ—, åœ¨æ–‡ä»¶ I/O æˆ–ç½‘ç»œ I/O ä¸­è¯»å–æ•°æ®æµæ—¶éœ€è¦ä½¿ç”¨ u8.
    // 16-bit	 i16(-2^Â¹âµ - 2^Â¹âµ-1)	  	                u16(0 - 2^Â¹â¶-1)                         å ç”¨ 2 ä¸ªå­—èŠ‚
    // 32-bit	 i32(-2^Â³Â¹ - 2^Â³Â¹-1)	  	                u32(0 - 2^Â³Â²-1)                         å ç”¨ 4 ä¸ªå­—èŠ‚
    // 64-bit	 i64(-2^â¶Â³ - 2^â¶Â³-1)	  	                u64(0 - 2^â¶â´-1)                         å ç”¨ 8 ä¸ªå­—èŠ‚
    // 128-bit	 i128(-2^Â¹Â²â· - 2^Â¹Â²â·-1)	  	                u128(0 - 2^Â¹Â²â¸-1)                       å ç”¨ 16 ä¸ªå­—èŠ‚
    // arch	     isize(-2^Â³Â¹ - 2^Â³Â¹-1 æˆ– -2^â¶Â³ - 2^â¶Â³-1)  	usize(0 - 2^Â³Â²-1 æˆ– 0 - 2^â¶â´-1)         å ç”¨ 4 æˆ– 8 ä¸ªå­—èŠ‚, å…·ä½“å–å†³äºæœºå™¨çš„å­—é•¿, å­—é•¿å¯ä»¥ç†è§£ä¸º 32ä½ç³»ç»Ÿ / 64 ä½ç³»ç»Ÿ

    // æœ‰ç¬¦å·æ•°: å¯ä»¥ä¸ºæ­£æ•°, ä¹Ÿå¯ä»¥ä¸ºè´Ÿæ•°, å’Œ 0; æœ‰ç¬¦å·æ•°ä»¥è¡¥ç å½¢å¼(two's complement representation) å­˜å‚¨; æ¯ä¸€ä¸ªæœ‰ç¬¦å·çš„å˜ä½“å¯ä»¥å‚¨å­˜åŒ…å«ä» -(2^n - 1) åˆ° 2^(n-1) - 1 åœ¨å†…çš„æ•°å­—
    // æ— ç¬¦å·æ•°: åªèƒ½ä¸ºæ­£æ•´æ•°å’Œ 0; æ— ç¬¦å·çš„å˜ä½“å¯ä»¥å‚¨å­˜ä» 0 åˆ° 2^(n-1) çš„æ•°å­—
    // isize å’Œ usize ç±»å‹ä¾èµ–è¿è¡Œç¨‹åºçš„è®¡ç®—æœºæ¶æ„:64 ä½æ¶æ„ä¸Šå®ƒä»¬æ˜¯ 64 ä½çš„, 32 ä½æ¶æ„ä¸Šå®ƒä»¬æ˜¯ 32 ä½çš„

    // æ•°å­—å­—é¢å€¼	                 ä¾‹å­
    // Decimal (åè¿›åˆ¶)	             98_222
    // Hex (åå…­è¿›åˆ¶)	             0xff
    // Octal (å…«è¿›åˆ¶)	             0o77
    // Binary (äºŒè¿›åˆ¶)	             0b1111_0000
    // Byte (å•å­—èŠ‚å­—ç¬¦)(ä»…é™äºu8)	  b'A'

    // æ•´å‹æ”¯æŒäºŒ, å…«, å, åå…­è¿›åˆ¶å’Œå•å­—èŠ‚å­—ç¬¦
    // rust å…è®¸ä½¿ç”¨ _ åšä¸ºåˆ†éš”ç¬¦ä»¥æ–¹ä¾¿è¯»æ•°, å¦‚ 1_000_000 ç­‰ä»·äº 1000000

    // æ•´å‹æº¢å‡º, å› ä¸º i8 æœ€å¤§åˆ° 255
    // è¿™å¥è¯ä¼šåœ¨ç¼–è¯‘é˜¶æ®µæŠ¥é”™, ä½†åœ¨ release é˜¶æ®µ, ä¼šå°† 256 å˜æˆ 0, 257 å˜æˆ 1, ä¾æ­¤ç±»æ¨. è¿™å«åšäºŒè¿›åˆ¶è¡¥ç åŒ…è£…(two's complement wrapping).
    // æ ‡å‡†åº“ä¸­æœ‰ä¸€ä¸ª Wrapping æ¥æ˜¾å¼å¤„ç†æº¢å‡º: https://doc.rust-lang.org/std/num/struct.Wrapping.html
    // ä¸è¿‡ Wrapping å¤§å¤šéƒ½å±äºå®éªŒä¸­çš„
    // let num: i8 = 256;

    // æµ®ç‚¹å‹
    // æœ‰ f32 å’Œ f64 ä¸¤ç§, åˆ†åˆ«å  32 ä½å’Œ 64 ä½, é»˜è®¤æ˜¯ f64
    // æµ®ç‚¹æ•°é‡‡ç”¨ IEEE-754 æ ‡å‡†è¡¨ç¤º. f32 æ˜¯å•ç²¾åº¦æµ®ç‚¹æ•°, f64 æ˜¯åŒç²¾åº¦æµ®ç‚¹æ•°
    println!("{}", 0.1 + 0.2); // 0.30000000000000004 å“ˆå“ˆå“ˆæˆ‘å°±çŸ¥é“

    // æ•°å€¼è¿ç®—
    // æ‰€æœ‰è¿ç®—ç¬¦åˆ—è¡¨: https://doc.rust-lang.org/book/appendix-02-operators.html
    println!("{}", 4.0 / 3.0); // 1.3333333333333333, å¦‚æœæ˜¯ float è¿ç®—äº§ç”Ÿå°æ•°, ä¼šå¸¦å°æ•°
    println!("{}", 4 / 3); // 1, å¦‚æœä¸¤ä¸ªæ•´å‹äº§ç”Ÿå°æ•°, ä¼šæŠŠå°æ•°æŠ¹æ‰, è¿™åœ¨ç®—æ³•é¢˜å¤§æ•°åŠ æ³•ç›¸å…³é¢˜ç›®ä¸­æ±‚å•†å¾ˆæœ‰ç”¨.

    let a: i8 = 4;
    let b: i8 = 0b1111;
    let c: f32 = 1.0;
    let d: i32 = 4;
    let e: f64 = 2.0;
    let f = 4u32; // å¯ä»¥é€šè¿‡ç›´æ¥ä½¿ç”¨ç±»å‹åç¼€æ¥å‘ŠçŸ¥ç¼–è¯‘å™¨è¿™ä¸ªæ•´å‹æ•°å­—æ˜¯ä¸ª u32 çš„, å¦åˆ™é»˜è®¤è¢«æ¨ç®—æˆ i32
    let g = MAX;
    let i = MIN;
    let j = INFINITY;
    let k = NEG_INFINITY;
    assert_eq!(b'A', 65u8); // äºŒè¿›åˆ¶å¯ä»¥ç”¨ b å‰ç¼€

    // ğŸ‘¿ å¿…é¡»æ˜¯ç›¸åŒç±»å‹æ‰èƒ½åšåŠ å‡ä¹˜é™¤å–ä½™
    println!("{}", a + b);
    println!("{} {} {} {}", c, d, e, f);
    println!("{} {} {} {}", g, i, j, k);

    // ğŸ‘¿ i8 å’Œ i32 æ— æ³•è¿›è¡Œè¿ç®—
    // println!("{}", a + d);

    // ğŸ‘¿ int ç±»å‹å’Œ float ç±»å‹ä¸èƒ½è¿›è¡Œè¿ç®—, è¯¸å¦‚æ­¤ç±», äº‘äº‘.
    // println!("{}", c * a);

    // å¸ƒå°”å‹
    let t = true;
    let f: bool = false; // æ˜¾å¼æŒ‡å®šç±»å‹æ³¨è§£
    let truely = t as i32; // å¯ä»¥é€šè¿‡ as å°† bool -> i32, u32, i8, usize... ä½†ä¸å¯ä»¥è½¬æˆå…¶ä»–ç±»å‹, æ¯”å¦‚ float, str; æ­¤å¤–åªèƒ½ bool -> int, åè¿‡æ¥ä¸è¡Œ
    let falsy = f as i32;
    println!("{} {} {} {}", t, f, truely, falsy);

    // å­—ç¬¦ç±»å‹
    // å­—ç¬¦ç±»å‹ä»£è¡¨çš„æ˜¯ä¸€ä¸ª Unicode æ ‡é‡å€¼.
    // å­—ç¬¦ç±»å‹æ˜¯è¯­è¨€ä¸­æœ€åŸç”Ÿçš„å­—æ¯ç±»å‹, å®ƒå¿…é¡»æ˜¯å•ä¸ªå­—ç¬¦, æ¯”å¦‚ 'a', 'b', ä½†å¯ä»¥æ˜¯ 'ğŒ†' 'ğŸ˜»' ç­‰å››å­—ç¬¦.
    // æ³¨æ„è¦è·Ÿå­—ç¬¦ä¸²åŒºåˆ†, å­—ç¬¦ç±»å‹ç”¨çš„æ˜¯å•å¼•å·, å­—ç¬¦ä¸²æ˜¯åŒå¼•å·
    // å…·ä½“åŒºåˆ†: https://doc.rust-lang.org/book/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
    // Rust çš„ char ç±»å‹çš„å¤§å°ä¸ºå››ä¸ªå­—èŠ‚, å¹¶ä»£è¡¨äº†ä¸€ä¸ª Unicode æ ‡é‡å€¼(Unicode Scalar Value)
    let f = 'z';
    let g = 'â„¤';
    let h = 'ğŸ˜»';
    let i = '\x2A';
    let j = '\u{CA0}';

    // ä½¿ç”¨ as æ“ä½œç¬¦å°†å­—ç¬¦è½¬ä¸ºæ•°å­—ç±»å‹, æ¯”å¦‚ % çš„åè¿›åˆ¶ ASCII æ˜¯ 37, é‚£ç»“æœå°±æ˜¯ 37
    // à²  æ˜¯ 3232, å¦‚æœå¼ºåˆ¶è½¬ i8 çš„è¯, é«˜ä½ä¼šè¢«æˆªæ–­, å˜æˆ -96
    let k = '%' as i8; // 37
    let l = 'à² ' as i8; // 96
    println!("{} {} {} {} {} {} {}", f, g, h, i, j, k, l);

    //: å¤åˆç±»å‹
    //: Rust æœ‰ä¸¤ç§åŸºæœ¬çš„å¤åˆç±»å‹: å…ƒç»„, æ•°ç»„

    /* å…ƒç»„ */
    // let a = [3; 5];
    let tup = (500, 6.4, "str");
    // æ ¹æ®ä¸‹æ ‡è·å–å…ƒç»„å…ƒç´ 
    println!("{}, {}", tup.0, tup.1);
    // è§£æ„å…ƒç»„, å› ä¸º let æ”¯æŒæ¨¡å¼åŒ¹é…, æ‰€ä»¥å¯ä»¥ç”¨æ¥è§£æ„å…ƒç»„.
    // å¦‚æœä½¿ç”¨å…ƒç»„è§£æ„, ä½ å¿…é¡»æŠŠæ‰€æœ‰å…ƒç´ éƒ½è§£æ„å‡ºæ¥, å¦åˆ™æŠ¥é”™...
    let (i, j, k) = tup;
    println!("The value of i is: {}", i);
    println!("{} {}", j, k);
    // æšä¸¾å…ƒç»„ä¸­çš„æ‰€æœ‰å€¼
    println!("{:?}", tup);
    // å¾ˆé•¿çš„å…ƒç»„æ— æ³•æ‰“å°, è¿™ä¹ˆæ“è›‹çš„å—...
    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    // println!("too long tuple: {:?}", too_long_tuple);
    // æ²¡æœ‰ä»»ä½•å€¼çš„å…ƒç»„ () æ˜¯ä¸€ç§ç‰¹æ®Šçš„ç±»å‹, åªæœ‰ä¸€ä¸ªå€¼, ä¹Ÿå†™æˆ (). è¯¥ç±»å‹è¢«ç§°ä¸º å•å…ƒç±»å‹(unit type),
    // è€Œè¯¥å€¼è¢«ç§°ä¸º å•å…ƒå€¼(unit value). å¦‚æœè¡¨è¾¾å¼ä¸è¿”å›ä»»ä½•å…¶ä»–å€¼, åˆ™ä¼šéšå¼è¿”å›å•å…ƒå€¼
    let l = ();
    println!("{:?}", l);
    let tup = (0,); // å¦‚æœå…ƒç»„åªæœ‰ä¸€ä¸ªå…ƒç´ , å¿…é¡»åŠ ä¸€ä¸ªé€—å·
    println!("{:?}", tup);

    /* æ•°ç»„ [T; N], å¿…é¡»æ˜¯ä¸€è‡´çš„ç±»å‹, ä¸”é•¿åº¦å¿…é¡»ä¸ºç¼–è¯‘æ—¶å¸¸é‡, é»˜è®¤ä¸å¯å˜ */
    // å¯¹äºåŸå§‹å›ºå®šé•¿åº¦æ•°ç»„, åªæœ‰å®ç° Copy trait çš„ç±»å‹æ‰èƒ½ä½œä¸ºå…¶å…ƒç´ , ä¹Ÿå°±æ˜¯è¯´, åªæœ‰å¯ä»¥åœ¨æä¸Šå­˜æ”¾çš„å…ƒç´ æ‰å¯ä»¥å­˜æ”¾åœ¨è¯¥ç±»å‹çš„æ•°ç»„ä¸­

    // let m = [1, 2, 3, 4, 5, ""]; // ğŸ‘¿ æŠ¥é”™, å¿…é¡»æ˜¯ä¸€è‡´çš„ç±»å‹
    let mut n = ["Yancey", "Sayaka"];

    // æ•°ç»„ä¸€æ—¦åˆ›å»ºå°±ä¸å¯ä¿®æ”¹é•¿åº¦äº†, å®ƒæ²¡æœ‰ push pop ç­‰æ–¹æ³•
    // æ­¤å¤–å’Œå…¶ä»–æ•°æ®ç±»å‹ä¸€æ ·é»˜è®¤æ˜¯ä¸å¯å˜çš„, é™¤éä½ åŠ ä¸Š mut, ä½†å³ä¾¿åŠ ä¸Šäº† mut, ä¹Ÿåªèƒ½ä¿®æ”¹å·±å­˜åœ¨äºç´¢å·ä½ä¸Šçš„å…ƒç´ 
    n[1] = "Yancey"; // å¯ä»¥
                     // n[5] = "hello"; // ğŸ‘¿ è¿è¡Œæ—¶å‡ºé”™, ç¼–è¯‘æ—¶æ˜¯æ— æ³•æ£€æµ‹æ•°ç»„è®¿é—®å…ƒç´ æº¢å‡ºçš„

    // for...in
    for val in n.iter() {
        println!("val is :{}", val);
    }

    // å¯¹äºé•¿åº¦å›ºå®šçš„, ç”¨æ•°ç»„æ¯”è¾ƒå¥½, å¯å˜çš„å»ºè®®ç”¨ vector
    let o = vec![1, 2, 3];
    println!("{:?}", o);
    // println!("{:?}", o[4]);  // ğŸ‘¿ ä¹Ÿè¿è¡Œæ—¶å‡ºé”™, ç¼–è¯‘æ—¶æ˜¯æ— æ³•æ£€æµ‹æ•°ç»„è®¿é—®å…ƒç´ æº¢å‡ºçš„

    // è¿™ä¸ªå°±æ¯”è¾ƒéªš, ç­‰ä»·äº [3, 3, 3, 3, 3]
    let p = [3; 5];
    println!("{:?}", p);

    // æˆ‘çˆ†å“­ qwq, ç”¨ js åˆ·åŠ¨æ€è§„åˆ’çš„ leetcode é¢˜, åˆå§‹åŒ–äºŒç»´æ•°ç»„è´¼éº»çƒ¦.
    let q = [[""; 5]; 5];

    // å¯¹äºæ•°ç»„çš„æ‰“å°, å’Œå…ƒç»„ç±»ä¼¼, éƒ½å¾—ç”¨ {:?}
    println!("{:?}", q);
    let u = n[0];
    println!("{:?}", u);

    /* èŒƒå›´ç±»å‹ */
    assert_eq!(std::ops::Range { start: 1, end: 5 }, (1..5)); // å‰é—­åå¼€
    assert_eq!(std::ops::RangeInclusive::new(1, 5), (1..=5)); // å‰é—­åé—­
    assert_eq!(1 + 2 + 3, (1..=3).sum()); // èŒƒå›´ç±»å‹è‡ªå¸¦ä¸€äº›æ–¹æ³•, æ¯”å¦‚ sum
    assert!((1..=3).contains(&2)); // èŒƒå›´ç±»å‹è‡ªå¸¦ä¸€äº›æ–¹æ³•, æ¯”å¦‚ contains
    assert_eq!((1..).end_bound(), Unbounded); // èŒƒå›´ç±»å‹è‡ªå¸¦ä¸€äº›æ–¹æ³•, æ¯”å¦‚ end_bound
    assert_eq!((..1).start_bound(), Unbounded); // èŒƒå›´ç±»å‹è‡ªå¸¦ä¸€äº›æ–¹æ³•, æ¯”å¦‚ start_bound
    assert_eq!((1..3).end_bound(), Excluded(&3)); // èŒƒå›´ç±»å‹è‡ªå¸¦ä¸€äº›æ–¹æ³•, æ¯”å¦‚ end_bound
    assert_eq!((1..=3).end_bound(), Included(&3)); // èŒƒå›´ç±»å‹è‡ªå¸¦ä¸€äº›æ–¹æ³•, æ¯”å¦‚ end_bound
    for _ in 1..=3 {} // èŒƒå›´ç±»å‹è‡ªå¸¦è¿­ä»£å™¨, å¯ä»¥ç›´æ¥ä½¿ç”¨ for...in

    /* åˆ‡ç‰‡ç±»å‹ */
    // åˆ‡ç‰‡(Slice)ç±»å‹æ˜¯å¯¹ä¸€ä¸ªæ•°ç»„(åŒ…æ‹¬å›ºå®šå¤§å°æ•°ç»„å’ŒåŠ¨æ€æ•°ç»„)çš„å¼•ç”¨ç‰‡æ®µ, ç­¾åä¸º &[T] å’Œ &mut [T].
    let arr = [1, 2, 3, 4];
    let vec = vec![1, 2, 3, 4];
    // let arr_2 = arr[1..]; ğŸ‘¿ ä¸èƒ½å¯¹æ•°ç»„/å¯å˜æ•°ç»„è¿™æ ·åˆ‡
    assert_eq!(&arr[1..], [2, 3, 4]); // åªèƒ½ä½¿ç”¨åˆ‡ç‰‡
    assert_eq!(&vec[1..], [2, 3, 4]); // åªèƒ½ä½¿ç”¨åˆ‡ç‰‡
    assert_eq!(&vec[1..].len(), &3); // len æ–¹æ³•, æ˜¯ const fn æ–¹æ³•
    assert!(&vec[4..].is_empty()); // is_empty æ–¹æ³•, æ˜¯ const fn æ–¹æ³•

    /* str å­—ç¬¦ä¸²ç±»å‹ */
    let str: &'static str = "Hello, world"; // 'static çš„ç”Ÿå‘½å‘¨æœŸèƒ½å¤Ÿå­˜æ´»äºæ•´ä¸ªç¨‹åºæœŸé—´. æ‰€æœ‰çš„å­—ç¬¦ä¸²å­—é¢å€¼éƒ½æ‹¥æœ‰ 'static ç”Ÿå‘½å‘¨æœŸ
    let ptr = str.as_ptr();
    let len = str.len();
    let str_1 = unsafe {
        let slice = std::slice::from_raw_parts(ptr, len);
        std::str::from_utf8(slice)
    };
    assert_eq!(str_1, Ok(str));

    /* åŸç”ŸæŒ‡é’ˆ */
    // è¡¨ç¤ºå†…å­˜åœ°å€çš„ç±»å‹ç§°ä¸ºæŒ‡é’ˆ, Rust æä¾›äº†å¤šç§æŒ‡é’ˆç±»å‹:
    // å¼•ç”¨(Reference)
    // åŸç”ŸæŒ‡é’ˆ(Raw Pointer)
    // å‡½æ•°æŒ‡é’ˆ(fn Pointer)
    // æ™ºèƒ½æŒ‡é’ˆ(Smart Pointer)

    // Rust åˆ†ä¸º Safe Rust å’Œ Unsafe Rust
    // å¼•ç”¨æ˜¯ä¸€ç§éç©ºæŒ‡é’ˆ, åœ¨ Safe Rust ä¸­, ç¼–è¯‘å™¨ä¼šå¯¹å¼•ç”¨è¿›è¡Œå€Ÿç”¨æ£€æŸ¥, ä»¥ä¿è¯å†…å­˜å®‰å…¨å’Œç±»å‹å®‰å…¨
    // è€ŒåŸç”ŸæŒ‡é’ˆæ˜¯ä¸å®‰å…¨çš„, æ¯”å¦‚åŸç”ŸæŒ‡é’ˆå¯èƒ½æŒ‡å‘ Null, æˆ–è€…ä¸€ä¸ªå·²ç»è¢«é‡Šæ”¾çš„å†…å­˜åŒºåŸŸ(æ‚¬å‚å¼•ç”¨)
    // å› ä¸ºä½¿ç”¨åŸç”ŸæŒ‡é’ˆçš„åœ°æ–¹ä¸åœ¨ Safe Rust çš„å¯æ§èŒƒå›´å†…, æ‰€ä»¥éœ€è¦ç¨‹åºå‘˜è‡ªå·±ä¿è¯å®‰å…¨.
    // Rust æ”¯æŒä¸¤ç§åŸç”ŸæŒ‡é’ˆ:
    // ä¸å¯å˜åŸç”ŸæŒ‡é’ˆ *const T
    // å¯å˜åŸç”ŸæŒ‡é’ˆ *mut T

    {
        let mut x = 10;
        let ptr_x = &mut x as *mut i32; // é€šè¿‡ as å°† &mut x å¯å˜å¼•ç”¨è½¬æ¢ä¸º *mut i32 å¯å˜åŸç”ŸæŒ‡é’ˆ ptr_x
        let y = Box::new(20); // é€šè¿‡ Box å°†æ•°å­— 20 å­˜åˆ°å †å†…å­˜ä¸Š
        let ptr_y = &*y as *const i32; // å°† y è½¬æ¢æˆåŸç”ŸæŒ‡é’ˆ ptr_y

        unsafe {
            *ptr_x += *ptr_y; // ä¸¤ä¸ªåŸç”ŸæŒ‡é’ˆç›¸åŠ 
        }
        assert_eq!(x, 30);
    }

    /* é›¶å¤§å°ç±»å‹(ZST) */
    // å•å…ƒç±»å‹å’Œå•å…ƒç»“æ„ä½“å¤§å°ä¸ºé›¶, å•å…ƒç±»å‹ç»„æˆçš„æ•°ç»„å¤§å°ä¹Ÿä¸ºé›¶
    // ZST ç±»å‹çš„ç‰¹ç‚¹æ˜¯, å®ƒä»¬çš„å€¼å°±æ˜¯å…¶æœ¬èº«, è¿è¡Œæ—¶å¹¶ä¸å ç”¨å†…å­˜ç©ºé—´. ZST ç±»å‹ä»£è¡¨çš„æ„ä¹‰æ­£æ˜¯ç©º
    // æ¯”è¾ƒæœ‰è¶£çš„å®ç°å°±æ˜¯ HashSet<T> å®é™…ä¸Šæ˜¯ç”± HashMap<K, ()> å‘å±•æ¥äº†.
    enum Void {}
    struct Foo;
    #[allow(unused)]
    struct Baz {
        foo: Foo,
        qux: (),
        baz: [u8; 0],
    }
    // å¯é€šè¿‡ std::mem::size_of() æ¥æŸ¥æ‰¾ä¸€ä¸ªè¡¨è¾¾å¼å ç”¨å†…å­˜çš„å­—èŠ‚å¤§å°
    assert_eq!(std::mem::size_of::<Baz>(), 0);
    assert_eq!(std::mem::size_of::<Void>(), 0);

    let vec = vec![(); 10];
    // ä½¿ç”¨è¿™ç§æ–¹å¼è¦æ¯” 0..10 è·å¾—è¾ƒé«˜çš„æ€§èƒ½, ä¸è¿‡ä¹Ÿæ— æ‰€è°“å§
    for i in vec {
        println!("{:?}", i);
    }

    for i in 0..10 {
        println!("{:?}", i);
    }

    /* never ç±»å‹ */
    // nerver ç±»å‹(!)æ˜¯ä¸€ä¸ªæ²¡æœ‰å€¼çš„ç±»å‹, è¡¨ç¤ºæ°¸è¿œä¸ä¼šå®Œæˆè®¡ç®—çš„ç»“æœ. ç”±äº Rust ä¸­çš„åº•ç±»å‹ç”¨å¹å·(!) è¡¨ç¤º, æ­¤ç±»å‹ä¹Ÿè¢«ç§°ä¸º Bang Type
    // nerver ç±»å‹ç³»ç»Ÿåˆå«åº•ç±»å‹(Bottom Type), åº•ç±»å‹æºè‡ªç±»å‹ç†è®ºçš„æœ¯è¯­, å®ƒçš„ç‰¹ç‚¹æ˜¯æ²¡æœ‰å€¼, å…¶æ¬¡æ˜¯æ˜¯å…¶ä»–ä»»æ„ç±»å‹çš„å­ç±»å‹.
    // å¦‚æœè¯´ ZST ç±»å‹è¡¨ç¤ºç©ºçš„è¯, é‚£ä¹ˆåº•ç±»å‹å°±è¡¨ç¤ºæ— . åº•ç±»å‹æ— å€¼, è€Œä¸”å®ƒå¯ä»¥ç­‰ä»·äºä»»æ„ç±»å‹.
    // Rust ä¸­çš„åº•ç±»å‹ç”¨å¹å·è¡¨ç¤º, æ­¤ç±»å‹ä¹Ÿè¢«ç§°ä¸º BangType, Rust ä¸­æœ‰å¾ˆå¤šç§æƒ…å†µç¡®å®æ²¡æœ‰å€¼, ä½†ä¸ºäº†ç±»å‹å®‰å…¨, å¿…é¡»æŠŠè¿™äº›æƒ…å†µçº³å…¥ç±»å‹ç³»ç»Ÿè¿›è¡Œç»Ÿä¸€å¤„ç†, è¿™äº›æƒ…å†µåŒ…æ‹¬:
    // - å‘æ•£å‡½æ•°(Diverging Function), æŒ‡ä¼šå¯¼è‡´çº¿ç¨‹å´©æºƒçš„ panic!(), æˆ–è€…ç”¨äºé€€å‡ºå‡½æ•°çš„ std::process::exit
    // - continue å’Œ break å…³é”®å­—, å®ƒä»¬åªæ˜¯è¡¨ç¤ºæµç¨‹çš„è·³è½¬, å¹¶ä¸ä¼šè¿”å›ä»€ä¹ˆ
    // - loop å¾ªç¯, loop å¾ªç¯è™½ç„¶å¯ä»¥è¿”å›æŸä¸ªå€¼, ä½†ä¹Ÿæœ‰éœ€è¦æ— é™å¾ªç¯çš„æ—¶å€™.
    // - ç©ºæšä¸¾, æ¯”å¦‚ enum Void {}, å®ƒå®Œå…¨æ²¡æœ‰ä»»ä½•æˆå‘˜, å› è€Œæ— æ³•å¯¹å…¶è¿›è¡Œå˜é‡ç»‘å®š, ä¸çŸ¥é“å¦‚ä½•åˆå§‹åŒ–å¹¶ä½¿ç”¨å®ƒ, æ‰€ä»¥å®ƒä¹Ÿæ˜¯åº•ç±»å‹.

    // ! çš„ç±»å‹è¡¨è¾¾å¼å¯ä»¥å¼ºè½¬ä¸ºä»»ä½•å…¶ä»–ç±»å‹. ç›®å‰ ! åªåœ¨ nightly ç‰ˆæœ¬, è¿˜ä¸ç¨³å®š.
    // let x: ! = panic!();
    // let y: u32 = x;
    // è¿”å› ! ç±»å‹

    fn foo() -> ! {
        loop {
            println!("nerver");
        }
    }

    #[allow(unused)]
    let i = if false {
        foo();
    } else {
        100
    };

    /* ç±»å‹æ¨å¯¼ä¸ Turbofish æ“ä½œç¬¦ */
    // Rust çš„ç±»å‹æ¨å¯¼å¹¶ä¸å¼ºå¤§, åªèƒ½åœ¨å±€éƒ¨èŒƒå›´å†…è¿›è¡Œç±»å‹æ¨å¯¼
    // å½“ Rust æ— æ³•ä»ä¸Šä¸‹æ–‡ä¸­è‡ªåŠ¨æ¨å¯¼å‡ºç±»å‹çš„æ—¶å€™, ç¼–è¯‘å™¨ä¼šé€šè¿‡é”™è¯¯ä¿¡æ¯æç¤ºä½ 
    let x = "1";
    // println!("{:?}", x.parse().unwrap()); // ğŸ˜ˆ can't call method `parse` on ambiguous numeric type `{integer}`, å› ä¸º Rust ä¸­çš„æ•°å­—ç±»å‹å¾ˆå¤š,  parse ä¸çŸ¥é“ä½ æƒ³è®© x è½¬æˆ i32 è¿˜æ˜¯å…¶ä»–, å› æ­¤ä½ éœ€è¦è‡ªå·±æŒ‡æ˜
    // å› æ­¤ä½ å¯ä»¥ç»™è¡¨è¾¾å¼èµ‹å€¼ç»™æŸä¸ªå˜é‡, ç„¶åç»™è¿™ä¸ªå˜é‡æ ‡æ³¨æ˜ç¡®çš„å€¼
    let int_x: i32 = x.parse().unwrap(); // è¿™æ ·æ˜¯å¯ä»¥çš„
    println!("{:?}", int_x);
    // Rust è¿˜æä¾›äº†ä¸€ç§æ ‡æ³¨ç±»å‹çš„æ–¹æ³•, ç”¨äºæ–¹ä¾¿åœ°åœ¨å€¼è¡¨è¾¾å¼ä¸­ç›´æ¥æ ‡æ³¨ç±»å‹
    // ä¸‹é¢è¿™ä¸ªä»£ç ä½¿ç”¨äº† parse::<i32>() è¿™æ ·çš„å½¢å¼ä¸ºæ³›å‹å‡½æ•°æ ‡æ³¨ç±»å‹, å°±é¿å…äº†æ–°å»ºä¸€ä¸ªå˜é‡, è¿™ç§æ ‡æ³¨ç±»å‹ ::<> çš„å½¢å¼å°±å«ä½œ turbofish æ“ä½œç¬¦
    println!("{:?}", x.parse::<i32>().unwrap());
    // Rust çš„ç±»å‹æ¨å¯¼è¿˜æ˜¯ä¸å¤Ÿå¼ºå¤§, ä¸‹é¢è¿™ä¸ªå±…ç„¶å‡ºé”™äº†.
    // let b = 1.is_positive(); // ğŸ˜ˆ you must specify a type for this binding, like `i32`: `x: i32`
    // ä½ å¿…é¡»ç»™å®ƒæ˜ç¡®çš„å˜é‡
    assert!((-1 as i32).is_negative());

    /* ç±»å‹è½¬æ¢ */
    // åœ¨ç¼–ç¨‹è¯­è¨€ä¸­, ç±»å‹è½¬æ¢åˆ†ä¸ºéšå¼ç±»å‹è½¬æ¢(Implicit Type Conversion)å’Œæ˜¾å¼ç±»å‹è½¬æ¢(ExplicitType Conversion).
    // éšå¼ç±»å‹è½¬æ¢æ˜¯ç”±ç¼–è¯‘å™¨æˆ–è§£é‡Šå™¨æ¥å®Œæˆçš„, å¼€å‘è€…å¹¶æœªå‚ä¸, æ‰€ä»¥åˆç§°ä¹‹ä¸ºå¼ºåˆ¶ç±»å‹è½¬æ¢(Type Coercion).
    // æ˜¾å¼ç±»å‹è½¬æ¢æ˜¯ç”±å¼€å‘è€…æŒ‡å®šçš„, å°±æ˜¯ä¸€èˆ¬æ„ä¹‰ä¸Šçš„ç±»å‹è½¬æ¢(Type Cast).
    //
    // è§£å¼•ç”¨: åˆ†ä¸ºè‡ªåŠ¨è§£å¼•ç”¨å’Œæ‰‹åŠ¨è§£å¼•ç”¨
    //
    // è‡ªåŠ¨è§£å¼•ç”¨æ˜¯ç¼–è¯‘å™¨æ¥åšçš„, ä½†è‡ªåŠ¨è§£å¼•ç”¨çš„è¡Œä¸ºå¯ä»¥ç”±å¼€å‘è€…æ¥å®šä¹‰, ä¸¾ä¸ªä¾‹å­:
    // æˆ‘ä»¬çŸ¥é“ Rust çš„å­—ç¬¦ä¸²ç›¸åŠ , å³å€¼åº”è¯¥æ˜¯ &str ç±»å‹, ä½†ä¸‹é¢æ˜¾ç„¶æ˜¯ &String.
    // ä¹‹æ‰€ä»¥ä¸æŠ¥é”™, æ˜¯å› ä¸º String ç±»å‹å®ç°äº† DeRef
    // ```
    // impl ops::Deref for String {
    //     type Target = str;
    //
    //     #[inline]
    //     fn deref(&self) -> &str {
    //         unsafe { str::from_utf8_unchecked(&self.vec) }
    //     }
    // }
    // ```
    assert_eq!(String::from("a") + &String::from("b"), "ab".to_string());
    // å…¶ä»–çš„, &Vec<T> å¯ä»¥è½¬æˆ &[T]; &Rc<T> å¯ä»¥è½¬æˆ &T
    //
    // æ‰‹åŠ¨è§£å¼•ç”¨
    // ä¸‹é¢è¿™ä¸ªä¾‹å­, clone æ–¹æ³•åœ¨ Re å’Œ &str ç±»å‹ä¸­éƒ½è¢«å®ç°, å› æ­¤è¦æƒ³æ˜¯ç»™ &str ä½¿ç”¨ clone, å¾—æ‰‹åŠ¨æŠŠ x è§£å¼•ç”¨ä¸€æ¬¡
    #[allow(unused)]
    let x = Rc::new("hello");
    #[allow(unused)]
    let y = x.clone();
    #[allow(unused)]
    let z = (*x).clone();

    #[allow(unused)]
    let x1 = x.as_ref();
    #[allow(unused)]
    let x2 = x.deref();
    #[allow(unused)]
    let x3 = "Hello".borrow();
    #[allow(unused)]
    let x4 = &*"Hello";
    #[allow(unused)]
    let x5 = &"Hello"[0..];

    // as cast
    // æœ€å¸¸è§çš„å°±æ˜¯ as, ç»å¸¸ç”¨æ¥è½¬æ¢æ•°å­—ç±»å‹, éœ€è¦æ³¨æ„é•¿ç±»å‹è½¬çŸ­ç±»å‹å¯èƒ½è¢«æˆªæ–­å¤„ç†
    // å¦å¤–å½“ä»æœ‰ç¬¦å·ç±»å‹å‘æ— ç¬¦å·ç±»å‹è½¬æ¢çš„æ—¶å€™, æœ€å¥½ä½¿ç”¨æ ‡å‡†åº“ä¸­æä¾›çš„ä¸“é—¨çš„æ–¹æ³•

    // as çš„æ— æ­§ä¹‰å®Œå…¨é™å®šè¯­æ³•
    struct S(i32);
    trait A {
        fn test(&self, i: i32);
    }
    trait B {
        fn test(&self, i: i32);
    }
    impl A for S {
        fn test(&self, i: i32) {
            println!("FromA: {:?}", i);
        }
    }
    impl B for S {
        fn test(&self, i: i32) {
            println!("FromA: {:?}", i);
        }
    }

    let s = S(1);
    // å½“ä½œ trait çš„é™æ€å‡½æ•°æ¥è°ƒç”¨
    A::test(&s, 1);
    B::test(&s, 1);
    // ä½¿ç”¨ as æ“ä½œç¬¦
    <S as A>::test(&s, 1);
    <S as B>::test(&s, 1);
    // è¿™ä¸¤ç§æ–¹å¼å«ä½œæ— æ­§ä¹‰å®Œå…¨é™å®šè¯­æ³•(Fully Qualified Syntax for Disambiguation)
    // å»ºè®®ä½¿ç”¨ç¬¬äºŒç§æ–¹å¼, å› ä¸º<S as A>::test() è¯­ä¹‰æ¯”è¾ƒå®Œæ•´, å®ƒè¡¨æ˜äº†è°ƒç”¨çš„æ˜¯ S ç»“æ„ä½“å®ç°çš„ trait A ä¸­çš„ test æ–¹æ³•

    // as è¿˜å¯ä»¥è¿›è¡Œç±»å‹å’Œå­ç±»å‹ç›¸äº’è½¬æ¢
    // ç”Ÿå‘½å‘¨æœŸæ ‡è®°å¯çœ‹ä½œå­ç±»å‹, æ¯”å¦‚ &'static str ç±»å‹æ˜¯ &'a str ç±»å‹çš„å­ç±»å‹ï¼Œ
    // å› ä¸ºäºŒè€…çš„ç”Ÿå‘½å‘¨æœŸæ ‡è®°ä¸åŒ, 'a å’Œ 'static éƒ½æ˜¯ç”Ÿå‘½å‘¨æœŸæ ‡è®°, å…¶ä¸­ 'a æ˜¯æ³›å‹æ ‡è®°, æ˜¯ &strçš„é€šç”¨å½¢å¼ï¼Œ
    // è€Œ 'static åˆ™æ˜¯ç‰¹æŒ‡é™æ€ç”Ÿå‘½å‘¨æœŸçš„ &str å­—ç¬¦ä¸². æ‰€ä»¥, é€šè¿‡ as æ“ä½œç¬¦è½¬æ¢å¯ä»¥å°† &'static str ç±»å‹è½¬ä¸º &'a str ç±»å‹
    let a: &'static str = "hello";
    let b = a as &str;
    #[allow(unused)]
    let c: &'static str = b as &'static str;

    // From å’Œ Into
    #[derive(Debug)]
    struct MySpecialNumber(u32);

    impl From<u32> for MySpecialNumber {
        fn from(num: u32) -> Self {
            MySpecialNumber(num)
        }
    }

    let existing_var = 30;
    #[allow(unused)]
    let my_num = MySpecialNumber::from(existing_var);
    #[allow(unused)]
    let my_num: MySpecialNumber = existing_var.into();
}
