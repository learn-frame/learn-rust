use std::{rc::Rc, sync::Arc};

pub fn entry() {
    lexical_scope();
    borrow();
    lifetimes_params();
    omit_lifetimes_params("Yancey Leo");
    lifetimes_bound("hi", "world", &String::from(""));
    smart_point_with_lifetimes();
}

///  å˜é‡ç»‘å®šå…·æœ‰"æ—¶ç©º"åŒé‡å±æ€§
/// - ç©ºé—´å±æ€§æ˜¯æŒ‡æ ‡è¯†ç¬¦ä¸å†…å­˜ç©ºé—´è¿›è¡Œäº†ç»‘å®š.
/// - æ—¶é—´å±æ€§æ˜¯æŒ‡ç»‘å®šçš„æ—¶æ•ˆæ€§, ä¹Ÿå°±æ˜¯æŒ‡å®ƒçš„ç”Ÿå­˜å‘¨æœŸ.
/// ä¸€ä¸ªç»‘å®šçš„ç”Ÿå­˜å‘¨æœŸä¹Ÿè¢«ç§°ä¸ºç”Ÿå‘½å‘¨æœŸ(lifetime), æ˜¯å’Œè¯æ³•ä½œç”¨åŸŸæœ‰å…³çš„
fn lexical_scope() {
    /* let ç§°ä¸º let binding, å®ƒåˆ›å»ºä¸€ä¸ªé»˜è®¤çš„è¯æ³•ä½œç”¨åŸŸ, è¯¥ä½œç”¨åŸŸå°±æ˜¯å®ƒçš„ç”Ÿå‘½å‘¨æœŸ */
    let a = 1;
    let b = "hello".to_string();

    /* èŠ±æ‹¬å·ä¹Ÿæœ‰è¯æ³•ä½œç”¨åŸŸ */
    {
        let inner_a = 1;
        let c = a;
        let d = b;
        println!("{} {} {}", inner_a, c, d);
    }

    // println!("{}", inner_a); // ğŸ˜ˆ: å¤–éƒ¨å–ä¸åˆ°å†…éƒ¨çš„ä½œç”¨åŸŸ
    // println!("{}", b); // ğŸ˜ˆ: b æ˜¯å¼•ç”¨è¯­ä¹‰, è¢«è½¬ç§»åˆ°äº†å†…éƒ¨è¯æ³•ä½œç”¨åŸŸ, å¤–éƒ¨å–ä¸åˆ°
    println!("{}", a); // 1, a æ˜¯å¤åˆ¶è¯­ä¹‰

    /* Option ä½œç”¨åŸŸ */
    let a = Some(String::from(""));
    match a {
        Some(s) => println!("{}", s),
        None => (),
    }
    // ğŸ˜ˆ: a æ˜¯ Some ç±»å‹, Some ç±»å‹æ˜¯å¦ä¸ºå¤åˆ¶è¯­ä¹‰è¿˜æ˜¯å¼•ç”¨è¯­ä¹‰å–å†³äºå†…éƒ¨å€¼çš„ç±»å‹
    //è¿™æ®µä»£ç  a è¢«ç§»åŠ¨åˆ° match é‡Œ, ä¸‹é¢ä»£ç å°±å–ä¸åˆ° a äº†, é™¤éä½ ä½¿ç”¨ match a {}
    // println!("{:?}", a);

    /*
       æ­¤å¤–, for, loop ä»¥åŠ while è¿™äº›å¾ªç¯è¯­å¥; if let å’Œ while let å—; å‡½æ•°; é—­åŒ…éƒ½ä¼šäº§ç”Ÿè¯æ³•ä½œç”¨åŸŸ
    */
    let s = "hello".to_string();
    let join = |i: &str| s + i;
    println!("{}", join(" world")); // "hello, world"
                                    //  println!("{}", s); // ğŸ˜ˆ:
}

/// å€Ÿç”¨è§„åˆ™
/// è§„åˆ™ä¸€: å€Ÿç”¨çš„ç”Ÿå‘½å‘¨æœŸä¸èƒ½é•¿äºå‡ºå€Ÿæ–¹(æ‹¥æœ‰æ‰€æœ‰æƒçš„å¯¹è±¡)çš„ç”Ÿå‘½å‘¨æœŸ
/// è§„åˆ™äºŒ: å¯å˜å€Ÿç”¨(å¼•ç”¨)ä¸èƒ½æœ‰åˆ«å(Alias), å› ä¸ºå¯å˜å€Ÿç”¨å…·æœ‰ç‹¬å æ€§
/// è§„åˆ™ä¸‰: ä¸å¯å˜å€Ÿç”¨(å¼•ç”¨)ä¸èƒ½å†æ¬¡å‡ºå€Ÿä¸ºå¯å˜å€Ÿç”¨
///
/// è§„åˆ™ä¸€ä¸»è¦æ˜¯ä¸ºäº†é˜²æ­¢æ‚¬å‚å¼•ç”¨, å› ä¸ºå¦‚æœå‡ºå€Ÿæ–¹å·²ç»è¢«ææ„äº†, ä½†å€Ÿç”¨ä¾ç„¶å­˜åœ¨, é‚£å°±ä¼šå‡ºç°æ‚¬å‚æŒ‡é’ˆ
/// è§„åˆ™äºŒå’Œè§„åˆ™ä¸‰å¯ä»¥ç»Ÿä¸€æ€»ç»“ä¸º: **å…±äº«ä¸å¯å˜, å¯å˜ä¸å…±äº«**, å³:
/// ä¸å¯å˜å€Ÿç”¨å¯ä»¥è¢«å‡ºå€Ÿå¤šæ¬¡, å› ä¸ºå®ƒä¸èƒ½ä¿®æ”¹å†…å­˜æ•°æ®, å› æ­¤å®ƒä¹Ÿè¢«ç§°ä¸ºå…±äº«å€Ÿç”¨(å¼•ç”¨). å¯å˜å€Ÿç”¨åªèƒ½å‡ºå€Ÿä¸€æ¬¡, å¦åˆ™, éš¾ä»¥é¢„æ–™æ•°æ®ä½•æ—¶ä½•åœ°ä¼šè¢«ä¿®æ”¹.
///
/// Rust ç¼–è¯‘å™¨æœ‰ä¸€ä¸ªå€Ÿç”¨æ£€æŸ¥å™¨(borrow checker), å®ƒæ¯”è¾ƒä½œç”¨åŸŸæ¥ç¡®ä¿æ‰€æœ‰çš„å€Ÿç”¨éƒ½æ˜¯æœ‰æ•ˆçš„
fn borrow() {
    // ä¸å…è®¸ä¸€ä¸ªå˜é‡å³ç”¨ä½œå¯å˜å€Ÿç”¨, ä¹Ÿç”¨ä½œä¸å¯å˜å€Ÿç”¨
    // ğŸ˜ˆ: cannot borrow `i` as mutable because it is also borrowed as immutable
    // fn add(a: &i32, b: &mut i32) {}
    // let mut i = 20;
    // add(&i, &mut i);

    // è§£å¼•ç”¨æ“ä½œä¼šè·å¾—æ‰€æœ‰æƒ
    // ä¸‹é¢è¿™æ®µä»£ç æ˜¯é”™çš„, å› ä¸º *s å¾—åˆ°äº† String, æœªå®ç° Copy trait, ä¸èƒ½å¤Ÿè¢«å€Ÿç”¨
    // fn join(s: &String) -> String {
    //     let append = *s;
    //     "Hello".to_string() + &append
    // }

    // ğŸ˜ˆ: å¦‚ä¸‹è¿™ä¸ªå†™æ³•æ˜¯é”™è¯¯çš„, å› ä¸ºè¿”å›å€¼æ˜¯ s çš„å¼•ç”¨
    // ä½† s åœ¨å‡½æ•°ä¹‹åå°±è¢«é”€æ¯, æ‰€ä»¥å¤–é¢æ˜¯ä¸å¯èƒ½æ‹¿åˆ°çš„
    // pub fn say_hi() -> &i32 {
    //     let s = 1;

    //     &s
    // }
    // ^ `x` dropped here while still borrowed

    // ğŸ˜ˆ: r ä¸€å¼€å§‹çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ 'a è¿™ä¸ªåŒºåŸŸ, ä½†å› ä¸ºåé¢å¼•ç”¨äº† x,
    // æ‰€ä»¥ç”Ÿå‘½å‘¨æœŸç¼©åˆ° 'b è¿™ä¸ªåŒºåŸŸ, å› æ­¤æœ€åæ‰“å° r æ—¶,
    // è¶…å‡ºäº† 'b è¿™ä¸ªåŒºåŸŸ, æ•…æŠ¥é”™
    // å³å€Ÿç”¨çš„ç”Ÿå‘½å‘¨æœŸä¸èƒ½é•¿äºå‡ºå€Ÿæ–¹çš„ç”Ÿå‘½å‘¨æœŸ
    // pub fn say_hello() {
    //     {
    //         let r;                // ---------+-- 'a
    //                               //          |
    //         {                     //          |
    //             let x = 5;        // -+-- 'b  |
    //             r = &x;           //  |       |
    //         }                     // -+       |
    //                               //          |
    //         println!("r: {}", r); //          |
    //     }                         // ---------+
    // }
}

/// ç”Ÿå‘½å‘¨æœŸå‚æ•°
///
/// ä¸Šé¢è¯´åˆ°å¯¹äºå‡½æ•°æœ¬åœ°å£°æ˜çš„æ‹¥æœ‰æ‰€æœ‰æƒçš„å€¼æˆ–è€…å€Ÿç”¨, Rust ç¼–è¯‘å™¨åŒ…å«çš„å€Ÿç”¨æ£€æŸ¥å™¨(borrow checker)å¯ä»¥æ£€æŸ¥å®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸ
/// ä½†æ˜¯å¯¹äºè·¨è¯æ³•ä½œç”¨åŸŸçš„å€Ÿç”¨, å€Ÿç”¨æ£€æŸ¥å™¨å°±æ— æ³•è‡ªåŠ¨æ¨æ–­å€Ÿç”¨çš„åˆæ³•æ€§äº†
/// è¿™ç§æƒ…å†µä¸‹, ä½ éœ€è¦ä¸»åŠ¨æ ‡è®°ç”Ÿå‘½å‘¨æœŸå‚æ•°, æ¥è¾…åŠ© Rust è¿›è¡Œå€Ÿç”¨æ£€æŸ¥
/// æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸå‚æ•°å¹¶ä¸èƒ½æ”¹å˜ä»»ä½•å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸé•¿çŸ­, å®ƒåªç”¨äºç¼–è¯‘å™¨çš„å€Ÿç”¨æ£€æŸ¥, æ¥é˜²æ­¢æ‚¬å‚æŒ‡é’ˆ.
fn lifetimes_params() {
    /// å‡½æ•°çš„ç”Ÿå‘½å‘¨æœŸ
    ///
    /// å‡½æ•°ååé¢çš„ <'a> ä¸ºç”Ÿå‘½å‘¨æœŸå‚æ•°çš„å£°æ˜, ä¸æ³›å‹å‚æ•°ç±»ä¼¼, å¿…é¡»å…ˆå£°æ˜æ‰èƒ½ä½¿ç”¨.
    /// å‡½æ•°æˆ–æ–¹æ³•å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸå«ä½œè¾“å…¥ç”Ÿå‘½å‘¨æœŸ(input lifetime), è€Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸè¢«ç§°ä¸ºè¾“å‡ºç”Ÿå‘½å‘¨æœŸ(output lifetime).
    ///
    /// ğŸ˜ˆ: ä¸‹é¢è¿™ä¸ªä¾‹å­, è¿”å›çš„æ˜¯ x æˆ–è€… y çš„å¼•ç”¨, ä½† Rust ä¼šé»˜è®¤ x å’Œ y çš„ç”Ÿå‘½ä¸­å‘¨æœŸæ˜¯ä¸åŒçš„, å°±ä¼šå‡ºé”™
    /// ```
    /// fn longest(x: &str, y: &str) -> &str {
    ///     if x.len() > y.len() {
    ///         x
    ///     } else {
    ///         y
    ///     }
    /// }
    /// ```
    ///
    /// æ‰€ä»¥ä½ è¦æ˜¾å¼æ ‡æ˜ä»–ä»¬çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ç›¸åŒ.
    /// å®ƒçš„å®é™…å«ä¹‰æ˜¯ longest å‡½æ•°è¿”å›çš„å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä¸ä¼ å…¥è¯¥å‡½æ•°çš„å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸçš„è¾ƒå°è€…ä¸€è‡´
    /// è¿™å°±æ˜¯æˆ‘ä»¬å‘Šè¯‰ Rust éœ€è¦å…¶ä¿è¯çš„çº¦æŸæ¡ä»¶
    fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
        if x.len() >= y.len() {
            x
        } else {
            y
        }
    }
    /// å¦‚æœä½ æƒ³ä¸ºæ¯ä¸ªå‚æ•°éƒ½æ ‡æ³¨ä¸åŒçš„ç”Ÿå‘½å‘¨æœŸä¹Ÿå¯ä»¥
    /// å› ä¸ºè¿™ä¸ªå‡½æ•°è¦æ±‚ x å’Œ y çš„ç”Ÿå‘½å‘¨æœŸç›¸åŒ, ä½ å¯ä»¥è®© 'b: 'a
    /// æ„æ€æ˜¯æ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•° 'b çš„å­˜æ´»æ—¶é—´é•¿äºæ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•° 'a(å³ 'b outlive 'a)
    fn the_longest<'a, 'b: 'a>(x: &'a str, y: &'b str) -> &'a str {
        if x.len() >= y.len() {
            x
        } else {
            y
        }
    }
    assert_eq!("a", longest("a", "b"));
    assert_eq!("a", the_longest("a", "b"));

    /// ğŸ˜ˆ: ç¦æ­¢åœ¨æ²¡æœ‰ä»»ä½•è¾“å…¥å‚æ•°çš„æƒ…å†µä¸‹è¿”å›å¼•ç”¨
    /// ä¸‹é¢çš„é”™è¯¯ä¹Ÿæ˜¯æ˜¾è€Œæ˜“è§çš„, s æ˜¯å‡½æ•°å†…éƒ¨çš„, åœ¨å‡½æ•°æ‰§è¡Œå®Œå°±è¢«ææ„äº†, æ‰€ä»¥å¤–é¢æ‹¿ä¸åˆ° s çš„å¼•ç”¨
    /// ```
    /// fn return_str<'a>() -> &'a str {
    ///     let mut s = "Rust".to_string();
    ///
    ///     for _ in 0..3 {
    ///         s.push_str(" Good");
    ///     }
    ///
    ///     &s[..]
    /// }
    /// ```
    ///
    /// æ¢æˆè¿”å› String ç±»å‹å°±å¥½äº†
    fn return_str() -> String {
        let mut s = "Rust".to_string();

        for _ in 0..3 {
            s.push_str(" Good");
        }

        s
    }
    assert_eq!(String::from("Rust Good Good Good"), return_str());

    /// ç»“æ„ä½“çš„ç”Ÿå‘½å‘¨æœŸ
    ///
    /// ä¸€ä¸ªå¸¸è§çš„ä¾‹å­, å¦‚æœç»“æ„ä½“ä¸­çš„æˆå‘˜ç”¨åˆ°äº† &str ç±»å‹, å°±å¿…é¡»å¾—ä½¿ç”¨ 'a
    /// è¿™é‡Œçš„ç”Ÿå‘½å‘¨æœŸå‚æ•°æ ‡è®°, å®é™…ä¸Šæ˜¯å’Œç¼–è¯‘å™¨çº¦å®šäº†ä¸€ä¸ªè§„åˆ™: ç»“æ„ä½“å®ä¾‹çš„ç”Ÿå‘½å‘¨æœŸåº”çŸ­äºæˆ–ç­‰äºä»»æ„ä¸€ä¸ªæˆå‘˜çš„ç”Ÿå‘½å‘¨æœŸ.
    #[allow(unused)]
    struct ImportantExcerpt<'a, T> {
        part: &'a str,
        age: T,
    }

    #[allow(unused)]
    fn exec_important_excerpt() {
        let novel = String::from("Call me Ishmael. Some years ago...");
        let first_sentence = novel.split('.').next().expect("Could not find a '.'");
        let instance = ImportantExcerpt {
            part: first_sentence,
            age: 1,
        };
        println!("{}", instance.part);
    }

    /// æ–¹æ³•å®šä¹‰ä¸­çš„ç”Ÿå‘½å‘¨æœŸ
    ///
    /// å› ä¸º struct ImportantExcerpt ç”¨åˆ°äº†ç”Ÿå‘½å‘¨æœŸå‚æ•°, æ‰€ä»¥åœ¨ impl ä¹Ÿå¿…é¡»æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸå‚æ•°
    impl<'a, T> ImportantExcerpt<'a, T> {
        #[allow(unused)]
        fn level(&self) -> i32 {
            3
        }

        #[allow(unused)]
        fn announce_and_return_part(&self, announcement: &str) -> &str {
            println!("Attention please: {}", announcement);
            self.part
        }
    }
    ///
    /// trait å¯¹è±¡å’Œç”Ÿå‘½å‘¨æœŸæœ‰é»˜è®¤éµå¾ªçš„è§„åˆ™:
    /// - trait å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸé»˜è®¤æ˜¯ 'static.
    /// - å¦‚æœå®ç° trait çš„ç±»å‹åŒ…å« &'a X æˆ– &'a mut X, åˆ™é»˜è®¤ç”Ÿå‘½å‘¨æœŸå°±æ˜¯ 'a.
    /// - å¦‚æœå®ç° trait çš„ç±»å‹åªæœ‰ T:'a, åˆ™é»˜è®¤ç”Ÿå‘½å‘¨æœŸå°±æ˜¯ 'a.
    /// - å¦‚æœå®ç° trait çš„ç±»å‹åŒ…å«å¤šä¸ªç±»ä¼¼ T:'a çš„ä» å¥, åˆ™ç”Ÿå‘½å‘¨æœŸéœ€è¦æ˜ç¡®æŒ‡å®š
    ///
    /// ä¸‹é¢è¿™ä¸ªå°±ä¸ç”¨

    trait Foo {}
    #[allow(unused)]
    struct Bar<'a> {
        x: &'a i32,
    }
    impl<'a> Foo for Bar<'a> {}
    fn trait_object_unneed_lifetimes() {
        let num = 5;
        let box_bar = Box::new(Bar { x: &num });
        #[allow(unused)]
        let obj = box_bar as Box<dyn Foo>;
    }
    trait_object_unneed_lifetimes();
    ///
    /// ä¸‹é¢è¿™ä¸ªå¿…é¡»
    /// Box<Foo<'a>> æ˜¯ä¸€ä¸ª trait å¯¹è±¡, å®ƒçš„é»˜è®¤ç”Ÿå‘½å‘¨æœŸæ˜¯ 'static çš„.
    /// è€Œç°åœ¨å®ç° trait Trait çš„ç±»å‹ Struct æœ‰ä¸€ä¸ª &'a [u32] ç±»å‹çš„æˆå‘˜, æ‰€ä»¥æ­¤æ—¶çš„ trait å¯¹è±¡ç”Ÿå‘½å‘¨æœŸåº”è¯¥æ˜¯ 'a.
    /// å› æ­¤, å¦‚æœæƒ³ä¿®å¤ä¸Šé¢çš„é”™è¯¯, åªéœ€è¦æ˜¾å¼åœ°ä¸º trait å¯¹è±¡å¢åŠ ç”Ÿå‘½å‘¨æœŸå‚æ•°,
    /// å°† Box<dyn Trait<'a>> æ”¹ä¸º Box<dyn Trait<'a> + 'a> å³å¯, æ­¤æ—¶è¯¥ trait å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸå°±æ˜¯ 'a, è¦†ç›–äº†é»˜è®¤çš„ 'static ç”Ÿå‘½å‘¨æœŸ
    trait Trait<'a> {}
    #[allow(unused)]
    struct Struct<'a> {
        s: &'a [u32],
    }
    impl<'a> Trait<'a> for Struct<'a> {}
    fn trait_object_lifetimes<'a>(s: &'a [u32]) -> Box<dyn Trait<'a> + 'a> {
        Box::new(Struct { s })
    }
    trait_object_lifetimes(&[1, 2, 3]);

    /// é™æ€ç”Ÿå‘½å‘¨æœŸå‚æ•°
    ///
    /// 'static çš„ç”Ÿå‘½å‘¨æœŸèƒ½å¤Ÿå­˜æ´»äºæ•´ä¸ªç¨‹åºæœŸé—´. æ‰€æœ‰çš„å­—ç¬¦ä¸²å­—é¢å€¼éƒ½æ‹¥æœ‰ 'static ç”Ÿå‘½å‘¨æœŸ
    #[allow(unused)]
    fn static_lifetimes_params() {
        let s: &'static str = "I have a static lifetime.";
        let y = s;
        println!("{} {}", s, y);
    }
}

/// çœç•¥ç”Ÿå‘½å‘¨æœŸå‚æ•°
///
/// å¯¹äºç†è®ºä¸Šéœ€è¦æ˜¾å¼åœ°æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸå‚æ•°çš„æƒ…å†µ, å®é™…ä¸­ä¾ç„¶å­˜åœ¨å¯ä»¥çœç•¥ç”Ÿå‘½å‘¨æœŸå‚æ•°çš„å¯èƒ½
///
/// ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™(Lifetime Elision Rule)å…±æœ‰ä¸‰æ¡:
/// 1. æ¯ä¸€ä¸ªæ˜¯å¼•ç”¨çš„å‚æ•°éƒ½æœ‰å®ƒè‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°
/// 2. å¦‚æœåªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°, é‚£ä¹ˆå®ƒè¢«èµ‹äºˆæ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°
/// 3. å¦‚æœæ–¹æ³•æœ‰å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°å¹¶ä¸”å…¶ä¸­ä¸€ä¸ªå‚æ•°æ˜¯ &self æˆ– &mut self, è¯´æ˜æ˜¯ä¸ªå¯¹è±¡çš„æ–¹æ³•, é‚£ä¹ˆæ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°è¢«èµ‹äºˆ self çš„ç”Ÿå‘½å‘¨æœŸ
///
/// ä¸‹é¢æ˜¯å¯ä»¥å¿½ç•¥çš„ä¸€äº›ä¾‹å­
fn omit_lifetimes_params(s: &str) -> &str {
    &s[..]
}
trait A {
    fn get_mut<T>(&mut self) -> &mut T;
    fn get<T>(&self) -> &T;
}

/// ç”Ÿå‘½å‘¨æœŸé™å®š
///
/// announcement çš„ç±»å‹æ˜¯æ³›å‹ T, å®ƒå¯ä»¥è¢«æ”¾å…¥ä»»ä½•å®ç°äº† where ä»å¥ä¸­æŒ‡å®šçš„ Display trait çš„ç±»å‹
/// åœ¨ Rust 2018 ç‰ˆæœ¬ä¸­ç¼–è¯‘å™¨å·²ç»å¯ä»¥è‡ªå·±åˆ¤æ–­äº†
fn lifetimes_bound<'a, T: 'a>(x: &'a str, y: &'a str, announcement: &'a T) -> &'a T
where
    T: std::fmt::Display + 'a,
{
    println!("Announcement! {}", announcement);
    if x.len() > y.len() {
        x
    } else {
        y
    };

    announcement
}

/// é™¤äº†æ™®é€šçš„å¼•ç”¨(å€Ÿç”¨)ç±»å‹, Rust è¿˜æä¾›å…·æœ‰ç§»åŠ¨è¯­ä¹‰(å¼•ç”¨è¯­ä¹‰)çš„æ™ºèƒ½æŒ‡é’ˆ.
/// æ™ºèƒ½æŒ‡é’ˆå’Œæ™®é€šå¼•ç”¨çš„åŒºåˆ«ä¹‹ä¸€å°±æ˜¯æ‰€æœ‰æƒçš„ä¸åŒ. æ™ºèƒ½æŒ‡é’ˆæ‹¥æœ‰èµ„æºçš„æ‰€æœ‰æƒ, è€Œæ™®é€šå¼•ç”¨åªæ˜¯å¯¹æ‰€æœ‰æƒçš„å€Ÿç”¨.
fn smart_point_with_lifetimes() {
    let a = Box::new(1);
    #[allow(unused)]
    let b = a;
    // println!("{}", a); ğŸ˜ˆ: borrow of moved value: `a`

    // è¿™ç§å¯¹ Box<T> ä½¿ç”¨æ“ä½œç¬¦(*)è¿›è¡Œè§£å¼•ç”¨è€Œè½¬ç§»æ‰€æœ‰æƒçš„è¡Œä¸º, è¢«ç§°ä¸ºè§£å¼•ç”¨ç§»åŠ¨
    // ä¹‹æ‰€ä»¥ Box æ”¯æŒè§£å¼•ç”¨ç§»åŠ¨, æ˜¯å› ä¸ºå®ƒæ”¯æŒ #[lang = "owned_box"]
    let c = Box::new(1);
    let d = Box::new(String::from("abc"));
    let e = *c;
    let f = *d;

    println!("{}", c); // 1
    println!("{} {}", e, f);

    // ğŸ˜ˆ: d è¢«è§£å¼•ç”¨åæ˜¯ä¸€ä¸ªå¼•ç”¨è¯­ä¹‰, å®ƒè¢«èµ‹å€¼ç»™ f åæ‰€æœ‰æƒä¹Ÿè¢«è½¬ç§»èµ°äº†, å› æ­¤åé¢å°±ä¸èƒ½å†è¯»å– d äº†
    // println!("{}", d);

    // Rc<T> æˆ– Arc<T> æ™ºèƒ½æŒ‡é’ˆä¸æ”¯æŒè§£å¼•ç”¨ç§»åŠ¨(ä½†è§£å¼•ç”¨å¤åˆ¶æ˜¯å¯ä»¥çš„)
    #[allow(unused)]
    let h = Rc::new(vec![1, 2, 3]);
    #[allow(unused)]
    let i = Arc::new(vec![1, 2, 3]);
    // let j = *h; // ğŸ˜ˆ: cannot move out of an `Rc`
    // let k = *i; // ğŸ˜ˆ: cannot move out of an `Arc`
}
