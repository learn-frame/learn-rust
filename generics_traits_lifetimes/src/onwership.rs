/// 所有权系统
///
/// 类型分为值类型(原始类型)和引用类型
///
/// 值类型是指数据直接存储在栈中的数据类型, 如数值, 布尔值, 结构体等都是值类型, 对值类型的操作效率一般比较高, 使用完立即会被回收
/// 值类型作为右值(在值表达式中)执行赋值操作时, 会自动复制一个新的值副本
///
/// 引用类型将数据存储在堆中, 而栈中只存放指向堆中数据的地址(指针), 比如数组, 字符串.
///
/// 为精确划分到底是值类型还是引用类型, 值语义(Value Semantic)和引用语义(Reference Semantic )被引入, 定义如下:
/// 值语义: 按位复制以后, 与原始对象无关.
/// 引用语义: 也叫指针语义, 一般是指将数据存储于堆内存中, 通过栈内存的指针来管理堆内存的数据, 并且引用语义**禁止按位复制**,
/// 因为按位复制只能复制栈上的指针, 堆上的数据就多了一个管理者, 多了一层内存安全的隐患, 举个例子:
///
/// ```
/// // 我们知道这段代码在 Rust 是错误的
/// // a 和 b 都是指针, 指向 vec![1] 这个堆, 如果 a 释放了 vec![1], 那么 b 就成了悬垂引用
/// // 所以 Rust 不允许多个指针同时指向一块内存.
/// // 下面的代码可以把 `let b = a;` 改成 `let b = &a;`
/// let a = vec![1];
/// let b = a;
/// println!("{:p} {:p}", a.as_ptr(), b.as_ptr()); // 出错
/// ```
///
/// 按位复制就是指栈复制, 也叫浅复制, 它只复制栈上的数据. 从底层逻辑上讲, 如果一个类型实现了 Copy trait, 其 clone 方法必须是按位复制的
/// 相对而言, 深复制就是对栈上和堆上的数据一起复制. 比如 Box<T> 无法实现 Copy
/// 下面这个例子就会报错, 因为 Box 无法实现 Copy trait
/// ```
/// #[derive(Debug, Clone, Copy)]
/// struct X<T> {
///     a: i32,
///     b: Box<[T]>,
/// }
/// ```
/// 在 Rust中, 由 Copytrait来区分值语义和引用语义. 与此同时, Rust 也引入了新的语义:
/// 复制(Copy)语义和移动(Move)语义. 复制语义对应值语义, 移动语义对应引用语义
///
/// 对于可以安全地在栈上进行按位复制的类型, 就只需要按位复制
/// 对于在堆上存储的数据, 因为无法安全地在战上进行按位复制, 如果要保证内存安全, 就必须进行深度复制
/// 但深度复制很费性能, 所以索性在栈上移动指向堆内存的指针地址.
///
/// 下面这个例子中, 变量 a 是 Vec<i32> 类型, 当赋值给变量 b 时, 默认行为不是按位复制, 而是移动
/// 所以只是把 a 的指针重新指向了 b, 这样就杜绝了两个指针引用同一个堆空间的情况, 从而保证了内存安全/
/// 这种一个值的所有权被转移给另外一个变量绑定的过程, 就叫作所有权转移.
///
/// ```
/// let a = vec![1];
/// let b = a;
/// println!("{:?}", b); // 不能在这里访问 a 了
/// ```
///
pub fn entry() {
    /* 结构体的所有权 */
    // 下面这个例子中, 虽然成员 a 和 b 都是值类型, 但整个结构体仍然不可以按位复制
    #[allow(unused)]
    #[derive(Debug)]
    struct A {
        a: i32,
        b: i32,
    }
    let a = A { a: 1, b: 1 };
    let b = a;
    println!("{:?}", b);
    // println!("{:?}", a); // 😈: move occurs because `a` has type `A`, which does not implement the `Copy` trait

    // 可以看到它的建议是主动给结构体实现 Copy trait, 这样就可以是复制语义的了
    #[allow(unused)]
    #[derive(Debug, Copy, Clone)]
    struct B {
        a: i32,
        b: i32,
    }
    let a = B { a: 1, b: 1 };
    let b = a;
    println!("{:?} {:?}", a, b);

    /* 枚举的所有权 */
    // 枚举中当成员均为复制语义类型时, 该枚举就是复制语义
    let a = (1, 2, 3);
    let b = a;
    println!("{:?} {:?}", a, b);

    let a = (1, vec![1]);
    let b = a;
    println!("{:?}", b);
    // println!("{:?} {:?}", a, b); // 😈: move occurs because `a` has type `(i32, Vec<i32>)`, which does not implement the `Copy` trait

    // 此外, 数组和 Option 类型都遵循这样的规则:
    // 如果元素都是复制语义类型, 也就是都实现了 Copy, 那么它们就可以接位复制, 否则就转移所有权
    let a = [1, 2, 3];
    let b = a;
    println!("{:?} {:?}", a, b);

    let a = Some(1);
    let b = a;
    println!("{:?} {:?}", a, b);
}
