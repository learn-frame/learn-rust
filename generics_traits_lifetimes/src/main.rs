mod generics;
mod lifetimes;
mod traits;

/// 所有权系统
///
/// 类型分为值类型(原始类型)和引用类型
///
/// 值类型是指数据直接存储在栈中的数据类型, 如数值, 布尔值, 结构体等都是值类型, 对值类型的操作效率一般比较高, 使用完立即会被回收
/// 值类型作为右值(在值表达式中)执行赋值操作时, 会自动复制一个新的值副本
///
/// 引用类型将数据存储在堆中, 而栈中只存放指向堆中数据的地址(指针), 比如数组, 字符串.
///
/// 为精确划分到底是值类型还是引用类型, 值语义(Value Semantic)和引用语义(Reference Semantic )被引入, 定义如下:
/// 值语义: 按位复制以后, 与原始对象无关.
/// 引用语义: 也叫指针语义, 一般是指将数据存储于堆内存中, 通过栈内存的指针来管理堆内存的数据, 并且引用语义**禁止按位复制**,
/// 因为按位复制只能复制栈上的指针, 堆上的数据就多了一个管理者, 多了一层内存安全的隐患, 举个例子:
///
/// ```
/// // 我们知道这段代码在 Rust 是错误的
/// // a 和 b 都是指针, 指向 vec![1] 这个堆, 如果 a 释放了 vec![1], 那么 b 就成了悬垂引用
/// // 所以 Rust 不允许多个指针同时指向一块内存.
/// // 下面的代码可以把 `let b = a;` 改成 `let b = &a;`
/// let a = vec![1];
/// let b = a;
/// println!("{:p} {:p}", a.as_ptr(), b.as_ptr()); // 出错
/// ```
///
/// 按位复制就是指栈复制, 也叫浅复制, 它只复制栈上的数据. 从底层逻辑上讲, 如果一个类型实现了 Copy trait, 其 clone 方法必须是按位复制的
/// 相对而言, 深复制就是对栈上和堆上的数据一起复制. 比如 Box<T> 无法实现 Copy
/// 下面这个例子就会报错, 因为 Box 无法实现 Copy trait
/// ```
/// #[derive(Debug, Clone, Copy)]
/// struct X<T> {
///     a: i32,
///     b: Box<[T]>,
/// }
/// ```
/// 在 Rust中, 由 Copytrait来区分值语义和引用语义. 与此同时, Rust 也引入了新的语义:
/// 复制(Copy)语义和移动(Move)语义. 复制语义对应值语义, 移动语义对应引用语义
///
/// 对于可以安全地在枝上进行按位复制的类型, 就只需要按位复制
/// 对于在堆上存储的数据, 因为无法安全地在战上进行按位复制, 如果要保证内存安全, 就必须进行深度复制
/// 但深度复制很费性能, 所以索性在栈上移动指向堆内存的指针地址
/// 这种一个值的所有权被转移给另外一个变量绑定的过程, 就叫作所有权转移.
/// 
/// 下面这个例子, println 语句在访问不到 a 了, 因为已经被转移给了 b
/// ```
/// let a = vec![1];
/// let b = a;
/// println!("{:?}", b);
/// ```
fn main() {
    generics::entry();
    traits::entry();
    lifetimes::entry();
}
