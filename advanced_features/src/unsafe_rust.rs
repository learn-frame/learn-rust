//! ä»¥ä¸‹äº”ç±»æ˜¯å¯ä»¥ä½¿ç”¨ unsafe çš„
//! è§£å¼•ç”¨è£¸æŒ‡é’ˆ
//! è°ƒç”¨ä¸å®‰å…¨çš„å‡½æ•°æˆ–æ–¹æ³•
//! è®¿é—®æˆ–ä¿®æ”¹å¯å˜é™æ€å˜é‡
//! å®ç°ä¸å®‰å…¨ trait
//! è®¿é—® union çš„å­—æ®µ
//!
//! è¦æ±‚è¿™äº”ç±»æ“ä½œå¿…é¡»ä½äºæ ‡è®°ä¸º unsafe çš„å—ä¸­, å°±èƒ½å¤ŸçŸ¥é“ä»»ä½•ä¸å†…å­˜å®‰å…¨ç›¸å…³çš„é”™è¯¯å¿…å®šä½äº unsafe å—å†…
//! ä¸ºäº†å°½å¯èƒ½éš”ç¦»ä¸å®‰å…¨ä»£ç , å°†ä¸å®‰å…¨ä»£ç å°è£…è¿›ä¸€ä¸ªå®‰å…¨çš„æŠ½è±¡å¹¶æä¾›å®‰å…¨ API æ˜¯ä¸€ä¸ªå¥½ä¸»æ„
use std::slice;

pub fn entry() {
    unsafe {
        dangerous();
    }

    let mut vec = [3; 19];
    let res = split_at_mut(&mut vec, 3);
    println!("{:?}", res);

    // use_unsafe_code(); // segmentation fault

    // unsafe {
    //     println!("Absolute value of -3 according to C: {}", my_c_function(-3));
    // }

    visit_and_update_mut_static_varibles();

    let u = MyUnion { f1: 1 };
    unsafe { u.f1 };
}

/// Rust ä¼šåœ¨ç¼–è¯‘æ—¶æ£€æµ‹æ‚¬å‚å¼•ç”¨, è€Œä¸å®‰å…¨çš„è£¸æŒ‡é’ˆ(raw pointer)å¯ä»¥è·³è¿‡è¿™ä¸ªé—®é¢˜
/// ä¸å¯å˜è£¸æŒ‡é’ˆ: *const T
/// å¯å˜è£¸æŒ‡é’ˆ: *mut T
///
/// è£¸æŒ‡é’ˆå’Œæ™®é€šå¼•ç”¨, æ™ºèƒ½æŒ‡é’ˆçš„åŒºåˆ«æœ‰:
/// å…è®¸å¿½ç•¥å€Ÿç”¨è§„åˆ™, å¯ä»¥åŒæ—¶æ‹¥æœ‰ä¸å¯å˜å’Œå¯å˜çš„æŒ‡é’ˆ, æˆ–å¤šä¸ªæŒ‡å‘ç›¸åŒä½ç½®çš„å¯å˜æŒ‡é’ˆ
/// ä¸ä¿è¯æŒ‡å‘æœ‰æ•ˆçš„å†…å­˜
/// å…è®¸ä¸ºç©º
/// ä¸èƒ½å®ç°ä»»ä½•è‡ªåŠ¨æ¸…ç†åŠŸèƒ½
pub fn dereferencing_a_raw_pointer() {
    let mut num = 5;

    // è¿™é‡Œæ²¡æœ‰å¼•å…¥ unsafe å…³é”®å­—.
    // å¯ä»¥åœ¨å®‰å…¨ä»£ç ä¸­åˆ›å»ºè£¸æŒ‡é’ˆ, åªæ˜¯ä¸èƒ½åœ¨ä¸å®‰å…¨å—ä¹‹å¤–è§£å¼•ç”¨è£¸æŒ‡é’ˆ
    let r1 = &num as *const i32; // ä½¿ç”¨ as å°†ä¸å¯å˜å’Œå¯å˜å¼•ç”¨å¼ºè½¬ä¸ºå¯¹åº”çš„è£¸æŒ‡é’ˆç±»å‹
    let r2 = &mut num as *mut i32;

    // åˆ›å»ºä¸€ä¸ªä¸èƒ½ç¡®å®šå…¶æœ‰æ•ˆæ€§çš„è£¸æŒ‡é’ˆ
    // å°è¯•ä½¿ç”¨ä»»æ„å†…å­˜æ˜¯æœªå®šä¹‰è¡Œä¸º: æ­¤åœ°å€å¯èƒ½æœ‰æ•°æ®ä¹Ÿå¯èƒ½æ²¡æœ‰, ç¼–è¯‘å™¨å¯èƒ½ä¼šä¼˜åŒ–æ‰è¿™ä¸ªå†…å­˜è®¿é—®, æˆ–è€…ç¨‹åºå¯èƒ½ä¼šå‡ºç°æ®µé”™è¯¯(segmentation fault)
    // ä¸€èˆ¬ä¹Ÿä¸ä¼šè¿™ä¹ˆå†™
    let address = 0x012345usize;
    let r = address as *const i32;

    // å¯ä»¥åœ¨å®‰å…¨ä»£ç ä¸­åˆ›å»ºè£¸æŒ‡é’ˆ, ä¸è¿‡ä¸èƒ½è§£å¼•ç”¨è£¸æŒ‡é’ˆå’Œè¯»å–å…¶æŒ‡å‘çš„æ•°æ®
    // å¦‚æœç¡®å®éœ€è¦è§£å¼•ç”¨, éœ€è¦åŒ…åœ¨ unsafe å—ä¸­
    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
        println!("r is: {}", *r);
    }

    // ç¨å¾®å¤ä¹ ä¸‹, åŒæ—¶å¼•ç”¨ä¸€ä¸ªå˜é‡çš„å¯å˜å¼•ç”¨å’Œéå¯å˜å¼•ç”¨å¯èƒ½ä¼šå¼•å‘é”™è¯¯
    // å› ä¸º Rust çš„æ‰€æœ‰æƒè§„åˆ™ä¸å…è®¸åœ¨æ‹¥æœ‰ä»»ä½•ä¸å¯å˜å¼•ç”¨çš„åŒæ—¶å†åˆ›å»ºä¸€ä¸ªå¯å˜å¼•ç”¨
    // ä½† unsafe å¯ä»¥, æ‰€ä»¥è¦å°å¿ƒæ½œåœ¨é€ æˆæ•°æ®çš„ç«äº‰
    // let r3 = &num;
    // let r4 = &mut num;
    // println!("{} {}", r3, r4);
}

// å¤ä¹ æ‚¬å‚å¼•ç”¨ - ä¸€ä¸ªé”™è¯¯çš„ä¾‹å­
// pub fn dangle() -> &String {
//     // s åœ¨ dangle å‡½æ•°ç»“æŸæ—¶å·²ç»è¢« drop äº†
//     let s = String::from("hello");

//     // ğŸ˜ˆ: å› æ­¤ä½ æ‹¿ä¸åˆ° s çš„å¼•ç”¨
//     &s
// }

// å¤ä¹ æ‚¬å‚å¼•ç”¨ - ä¸€ä¸ªæ­£ç¡®çš„ä¾‹å­
pub fn anti_dangle() -> String {
    let s = String::from("hello");
    // æ‰€æœ‰æƒè¢«ç§»åŠ¨å‡ºå», æ‰€ä»¥æ²¡æœ‰å€¼è¢«é‡Šæ”¾
    s
}

// è£¸æŒ‡é’ˆè™½ç„¶å¾ˆå±é™©, ä½†å®ƒä¹Ÿæœ‰å®ƒçš„ç”¨é€”:
// 1. è°ƒç”¨ C ä»£ç æ¥å£(C è¯­è¨€: mmp!)
// 2. æ„å»ºå€Ÿç”¨æ£€æŸ¥å™¨æ— æ³•ç†è§£çš„å®‰å…¨æŠ½è±¡

// unsafe çš„å‡½æ•°å¿…é¡»ç”¨ unsafe ä»£ç å—æ¥è°ƒç”¨
unsafe fn dangerous() {}
// unsafe {
//     dangerous();
// }

// split_at_mut æ˜¯æ ‡å‡†åº“ä¸­çš„ä¸€ä¸ªæ–¹æ³•, ç”¨æˆ·è¿”å›ä¸€ä¸ªä»åŸå§‹ slice çš„å¼€å¤´ç›´åˆ° mid ç´¢å¼•, å¦ä¸€ä¸ªä» mid ç›´åˆ°åŸ slice çš„ç»“å°¾çš„å…ƒç»„
// ä½†ä¸‹é¢çš„å®ç°ä¸­, Rust çš„å€Ÿç”¨æ£€æŸ¥å™¨ä¸èƒ½ç†è§£æˆ‘ä»¬è¦å€Ÿç”¨è¿™ä¸ª slice çš„ä¸¤ä¸ªä¸åŒéƒ¨åˆ†
// å®ƒåªçŸ¥é“æˆ‘ä»¬å€Ÿç”¨äº†åŒä¸€ä¸ª slice ä¸¤æ¬¡, æœ¬è´¨ä¸Šå€Ÿç”¨ slice çš„ä¸åŒéƒ¨åˆ†æ˜¯å¯ä»¥çš„, å› ä¸ºç»“æœä¸¤ä¸ª slice ä¸ä¼šé‡å , ä¸è¿‡ Rust è¿˜æ²¡æœ‰æ™ºèƒ½åˆ°èƒ½å¤Ÿç†è§£è¿™äº›
// fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
//     let len = slice.len();

//     assert!(mid <= len);

//     // Rust çš„å€Ÿç”¨æ£€æŸ¥å™¨ä¸èƒ½ç†è§£æˆ‘ä»¬è¦å€Ÿç”¨è¿™ä¸ª slice çš„ä¸¤ä¸ªä¸åŒéƒ¨åˆ†
//     (&mut slice[..mid], &mut slice[mid..])
// }

// æ— éœ€å°† split_at_mut å‡½æ•°çš„ç»“æœæ ‡è®°ä¸º unsafe, å¹¶å¯ä»¥åœ¨å®‰å…¨ Rust ä¸­è°ƒç”¨æ­¤å‡½æ•°
// æ¢å¥è¯è¯´, è™½ç„¶ç”¨äº†è£¸æŒ‡é’ˆè¿™ç§ä¸å®‰å…¨çš„åšæ³•, ä½†é€šè¿‡ä¸€ç³»åˆ—æ“ä½œ, ä¿è¯äº†å±€éƒ¨ä¸å®‰å…¨, æ•´ä½“å®‰å…¨
fn split_at_mut<T>(vec: &mut [T], mid: usize) -> (&mut [T], &mut [T]) {
    let len = vec.len();
    // as_mut_ptr è¿”å›ä¸€ä¸ª *mut i32 ç±»å‹çš„è£¸æŒ‡é’ˆ
    let ptr = vec.as_mut_ptr();

    assert!(mid <= len);

    unsafe {
        (
            // slice::from_raw_parts_mut å‡½æ•°è·å–ä¸€ä¸ªè£¸æŒ‡é’ˆå’Œä¸€ä¸ªé•¿åº¦æ¥åˆ›å»ºä¸€ä¸ª slice
            // ä»å¼€å¤´æˆªå–åˆ° mid, å› ä¸ºæœ‰äº† mid å¿…ç„¶å°äºç­‰äº len çš„æ–­è¨€, ä¿è¯ä¸ä¼šæº¢å‡º
            slice::from_raw_parts_mut(ptr, mid),
            // ä» mid æˆªå–åˆ°æœ€å, ä¿è¯ä¸ä¼šæº¢å‡º
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}

// å¦‚æœä¸åŠ ä»»ä½•é™åˆ¶, ä½¿ç”¨è‡†æµ‹ä¸ºæœ‰æ•ˆçš„ slice ä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸º
pub fn use_unsafe_code() {
    let address = 0x01234usize;
    let r = address as *mut i32;

    let slice: &[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
    println!("{:?}", slice);
}

// extern ç”¨äºé›†æˆå…¶ä»–è¯­è¨€çš„æ¥å£, ç§°ä½œå¤–éƒ¨å‡½æ•°æ¥å£(Foreign Function Interface, FFI)
// å…¶ä»–è¯­è¨€çš„æ¥å£æ€»æ˜¯ä¸å®‰å…¨çš„, ä½ éœ€è¦åŒ…è£¹åœ¨ unsafe è¯­å¥å—ä¸­æ‰§è¡Œ
// "C" éƒ¨åˆ†å®šä¹‰äº†å¤–éƒ¨å‡½æ•°æ‰€ä½¿ç”¨çš„åº”ç”¨äºŒè¿›åˆ¶æ¥å£(application binary interface, ABI)
extern "C" {
    #[allow(unused)]
    fn my_c_function(input: i32) -> i32;
}

// ä»å…¶å®ƒè¯­è¨€è°ƒç”¨ Rust å‡½æ•°
#[no_mangle]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}

// å…¨å±€å˜é‡åœ¨ Rust ä¸­è¢«ç§°ä¸ºé™æ€å˜é‡, é™æ€å˜é‡åªèƒ½å‚¨å­˜æ‹¥æœ‰ 'static ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨
// è¿™æ„å‘³ç€ Rust ç¼–è¯‘å™¨å¯ä»¥è‡ªå·±è®¡ç®—å‡ºå…¶ç”Ÿå‘½å‘¨æœŸè€Œæ— éœ€æ˜¾å¼æ ‡æ³¨. è®¿é—®ä¸å¯å˜é™æ€å˜é‡æ˜¯å®‰å…¨çš„
// é™æ€å˜é‡å’Œå¸¸é‡çš„åŒºåˆ«:
// 1. é™æ€å˜é‡ä¸­çš„å€¼æœ‰ä¸€ä¸ªå›ºå®šçš„å†…å­˜åœ°å€, ä½¿ç”¨è¿™ä¸ªå€¼æ€»æ˜¯ä¼šè®¿é—®ç›¸åŒçš„åœ°å€
// 2. å¸¸é‡åˆ™å…è®¸åœ¨ä»»ä½•è¢«ç”¨åˆ°çš„æ—¶å€™å¤åˆ¶å…¶æ•°æ®
// 3. å¸¸é‡ä¸å¯æ”¹å˜è€Œé™æ€å˜é‡å¯ä»¥æ”¹å˜, ä½†è®¿é—®å’Œä¿®æ”¹å¯å˜é™æ€å˜é‡éƒ½æ˜¯ä¸å®‰å…¨çš„
static STATIC_VARIABLE: &str = "Hello, world!";

// æ‹¥æœ‰å¯ä»¥å…¨å±€è®¿é—®çš„å¯å˜æ•°æ®, éš¾ä»¥ä¿è¯ä¸å­˜åœ¨æ•°æ®ç«äº‰, å°¤å…¶æ˜¯åœ¨å¤šçº¿ç¨‹,
// è¿™å°±æ˜¯ä¸ºä½• Rust è®¤ä¸ºå¯å˜é™æ€å˜é‡æ˜¯ä¸å®‰å…¨çš„
static mut MUT_STATIC_VARIABLE: &str = "Hello, world!";

fn visit_and_update_mut_static_varibles() {
    println!("{}", STATIC_VARIABLE);

    unsafe {
        println!("{}", MUT_STATIC_VARIABLE);

        MUT_STATIC_VARIABLE = "Hi, world!";
    }
}

unsafe trait Foo {
    // methods go here
}

// å¦‚æœä¸€ä¸ª trait è¢«æ ‡è®°äº† unsafe, å®ƒçš„å®ç°ä¹Ÿæ˜¯ unsafe çš„
unsafe impl Foo for i32 {
    // method implementations go here
}

// è”åˆä½“ç±»å‹
#[repr(C)]
union MyUnion {
    f1: u32,
    f2: f32,
}
